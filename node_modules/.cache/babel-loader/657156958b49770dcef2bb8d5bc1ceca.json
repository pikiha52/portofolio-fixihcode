{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseProxyResponse = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)('https-proxy-agent:parse-proxy-response');\n\nfunction parseProxyResponse(socket) {\n  return new Promise((resolve, reject) => {\n    // we need to buffer any HTTP traffic that happens with the proxy before we get\n    // the CONNECT response, so that if the response is anything other than an \"200\"\n    // response code, then we can re-play the \"data\" events on the socket once the\n    // HTTP parser is hooked up...\n    let buffersLength = 0;\n    const buffers = [];\n\n    function read() {\n      const b = socket.read();\n      if (b) ondata(b);else socket.once('readable', read);\n    }\n\n    function cleanup() {\n      socket.removeListener('end', onend);\n      socket.removeListener('error', onerror);\n      socket.removeListener('readable', read);\n    }\n\n    function onend() {\n      cleanup();\n      debug('onend');\n      reject(new Error('Proxy connection ended before receiving CONNECT response'));\n    }\n\n    function onerror(err) {\n      cleanup();\n      debug('onerror %o', err);\n      reject(err);\n    }\n\n    function ondata(b) {\n      buffers.push(b);\n      buffersLength += b.length;\n      const buffered = Buffer.concat(buffers, buffersLength);\n      const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n\n      if (endOfHeaders === -1) {\n        // keep buffering\n        debug('have not received end of HTTP headers yet...');\n        read();\n        return;\n      }\n\n      const headerParts = buffered.slice(0, endOfHeaders).toString('ascii').split('\\r\\n');\n      const firstLine = headerParts.shift();\n\n      if (!firstLine) {\n        socket.destroy();\n        return reject(new Error('No header received from proxy CONNECT response'));\n      }\n\n      const firstLineParts = firstLine.split(' ');\n      const statusCode = +firstLineParts[1];\n      const statusText = firstLineParts.slice(2).join(' ');\n      const headers = {};\n\n      for (const header of headerParts) {\n        if (!header) continue;\n        const firstColon = header.indexOf(':');\n\n        if (firstColon === -1) {\n          socket.destroy();\n          return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n        }\n\n        const key = header.slice(0, firstColon).toLowerCase();\n        const value = header.slice(firstColon + 1).trimStart();\n        const current = headers[key];\n\n        if (typeof current === 'string') {\n          headers[key] = [current, value];\n        } else if (Array.isArray(current)) {\n          current.push(value);\n        } else {\n          headers[key] = value;\n        }\n      }\n\n      debug('got proxy server response: %o %o', firstLine, headers);\n      cleanup();\n      resolve({\n        connect: {\n          statusCode,\n          statusText,\n          headers\n        },\n        buffered\n      });\n    }\n\n    socket.on('error', onerror);\n    socket.on('end', onend);\n    read();\n  });\n}\n\nexports.parseProxyResponse = parseProxyResponse;","map":{"version":3,"mappings":"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","names":["debug","parseProxyResponse","socket","Promise","resolve","reject","buffersLength","buffers","read","b","ondata","once","cleanup","removeListener","onend","onerror","Error","err","push","length","buffered","Buffer","concat","endOfHeaders","indexOf","headerParts","slice","toString","split","firstLine","shift","destroy","firstLineParts","statusCode","statusText","join","headers","header","firstColon","key","toLowerCase","value","trimStart","current","Array","isArray","connect","on","exports"],"sourceRoot":"","sources":["../src/parse-proxy-response.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}