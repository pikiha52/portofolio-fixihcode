{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/**\n * vue-meta v2.4.0\n * (c) 2020\n * - Declan de Wet\n * - Sébastien Chopin (@Atinux)\n * - Pim (@pimlie)\n * - All the amazing contributors\n * @license MIT\n */\nimport deepmerge from 'deepmerge';\nvar version = \"2.4.0\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n/**\n * checks if passed argument is an array\n * @param  {any}  arg - the object to check\n * @return {Boolean} - true if `arg` is an array\n */\n\n\nfunction isArray(arg) {\n  return Array.isArray(arg);\n}\n\nfunction isUndefined(arg) {\n  return typeof arg === 'undefined';\n}\n\nfunction isObject(arg) {\n  return _typeof(arg) === 'object';\n}\n\nfunction isPureObject(arg) {\n  return _typeof(arg) === 'object' && arg !== null;\n}\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nfunction hasGlobalWindowFn() {\n  try {\n    return !isUndefined(window);\n  } catch (e) {\n    return false;\n  }\n}\n\nvar hasGlobalWindow = hasGlobalWindowFn();\n\nvar _global = hasGlobalWindow ? window : global;\n\nvar console = _global.console || {};\n\nfunction warn(str) {\n  /* istanbul ignore next */\n  if (!console || !console.warn) {\n    return;\n  }\n\n  console.warn(str);\n}\n\nvar showWarningNotSupported = function showWarningNotSupported() {\n  return warn('This vue app/component has no vue-meta configuration');\n};\n/**\n * These are constant variables used throughout the application.\n */\n// set some sane defaults\n\n\nvar defaultInfo = {\n  title: undefined,\n  titleChunk: '',\n  titleTemplate: '%s',\n  htmlAttrs: {},\n  bodyAttrs: {},\n  headAttrs: {},\n  base: [],\n  link: [],\n  meta: [],\n  style: [],\n  script: [],\n  noscript: [],\n  __dangerouslyDisableSanitizers: [],\n  __dangerouslyDisableSanitizersByTagID: {}\n};\nvar rootConfigKey = '_vueMeta'; // This is the name of the component option that contains all the information that\n// gets converted to the various meta tags & attributes for the page.\n\nvar keyName = 'metaInfo'; // This is the attribute vue-meta arguments on elements to know which it should\n// manage and which it should ignore.\n\nvar attribute = 'data-vue-meta'; // This is the attribute that goes on the `html` tag to inform `vue-meta`\n// that the server has already generated the meta tags for the initial render.\n\nvar ssrAttribute = 'data-vue-meta-server-rendered'; // This is the property that tells vue-meta to overwrite (instead of append)\n// an item in a tag list. For example, if you have two `meta` tag list items\n// that both have `vmid` of \"description\", then vue-meta will overwrite the\n// shallowest one with the deepest one.\n\nvar tagIDKeyName = 'vmid'; // This is the key name for possible meta templates\n\nvar metaTemplateKeyName = 'template'; // This is the key name for the content-holding property\n\nvar contentKeyName = 'content'; // The id used for the ssr app\n\nvar ssrAppId = 'ssr'; // How long meta update\n\nvar debounceWait = 10; // How long meta update\n\nvar waitOnDestroyed = true;\nvar defaultOptions = {\n  keyName: keyName,\n  attribute: attribute,\n  ssrAttribute: ssrAttribute,\n  tagIDKeyName: tagIDKeyName,\n  contentKeyName: contentKeyName,\n  metaTemplateKeyName: metaTemplateKeyName,\n  waitOnDestroyed: waitOnDestroyed,\n  debounceWait: debounceWait,\n  ssrAppId: ssrAppId\n}; // might be a bit ugly, but minimizes the browser bundles a bit\n\nvar defaultInfoKeys = Object.keys(defaultInfo); // The metaInfo property keys which are used to disable escaping\n\nvar disableOptionKeys = [defaultInfoKeys[12], defaultInfoKeys[13]]; // List of metaInfo property keys which are configuration options (and dont generate html)\n\nvar metaInfoOptionKeys = [defaultInfoKeys[1], defaultInfoKeys[2], 'changed'].concat(disableOptionKeys); // List of metaInfo property keys which only generates attributes and no tags\n\nvar metaInfoAttributeKeys = [defaultInfoKeys[3], defaultInfoKeys[4], defaultInfoKeys[5]]; // HTML elements which support the onload event\n\nvar tagsSupportingOnload = ['link', 'style', 'script']; // HTML elements which dont have a head tag (shortened to our needs)\n// see: https://www.w3.org/TR/html52/document-metadata.html\n\nvar tagsWithoutEndTag = ['base', 'meta', 'link']; // HTML elements which can have inner content (shortened to our needs)\n\nvar tagsWithInnerContent = ['noscript', 'script', 'style']; // Attributes which are inserted as childNodes instead of HTMLAttribute\n\nvar tagAttributeAsInnerContent = ['innerHTML', 'cssText', 'json'];\nvar tagProperties = ['once', 'skip', 'template']; // Attributes which should be added with data- prefix\n\nvar commonDataAttributes = ['body', 'pbody']; // from: https://github.com/kangax/html-minifier/blob/gh-pages/src/htmlminifier.js#L202\n\nvar booleanHtmlAttributes = ['allowfullscreen', 'amp', 'amp-boilerplate', 'async', 'autofocus', 'autoplay', 'checked', 'compact', 'controls', 'declare', 'default', 'defaultchecked', 'defaultmuted', 'defaultselected', 'defer', 'disabled', 'enabled', 'formnovalidate', 'hidden', 'indeterminate', 'inert', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nohref', 'noresize', 'noshade', 'novalidate', 'nowrap', 'open', 'pauseonexit', 'readonly', 'required', 'reversed', 'scoped', 'seamless', 'selected', 'sortable', 'truespeed', 'typemustmatch', 'visible'];\nvar batchId = null;\n\nfunction triggerUpdate(_ref, rootVm, hookName) {\n  var debounceWait = _ref.debounceWait; // if an update was triggered during initialization or when an update was triggered by the\n  // metaInfo watcher, set initialized to null\n  // then we keep falsy value but know we need to run a triggerUpdate after initialization\n\n  if (!rootVm[rootConfigKey].initialized && (rootVm[rootConfigKey].initializing || hookName === 'watcher')) {\n    rootVm[rootConfigKey].initialized = null;\n  }\n\n  if (rootVm[rootConfigKey].initialized && !rootVm[rootConfigKey].pausing) {\n    // batch potential DOM updates to prevent extraneous re-rendering\n    // eslint-disable-next-line no-void\n    batchUpdate(function () {\n      return void rootVm.$meta().refresh();\n    }, debounceWait);\n  }\n}\n/**\n * Performs a batched update.\n *\n * @param  {(null|Number)} id - the ID of this update\n * @param  {Function} callback - the update to perform\n * @return {Number} id - a new ID\n */\n\n\nfunction batchUpdate(callback, timeout) {\n  timeout = timeout === undefined ? 10 : timeout;\n\n  if (!timeout) {\n    callback();\n    return;\n  }\n\n  clearTimeout(batchId);\n  batchId = setTimeout(function () {\n    callback();\n  }, timeout);\n  return batchId;\n}\n/*\n * To reduce build size, this file provides simple polyfills without\n * overly excessive type checking and without modifying\n * the global Array.prototype\n * The polyfills are automatically removed in the commonjs build\n * Also, only files in client/ & shared/ should use these functions\n * files in server/ still use normal js function\n */\n\n\nfunction find(array, predicate, thisArg) {\n  if (!Array.prototype.find) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return array[idx];\n      }\n    }\n\n    return;\n  }\n\n  return array.find(predicate, thisArg);\n}\n\nfunction findIndex(array, predicate, thisArg) {\n  if (!Array.prototype.findIndex) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return idx;\n      }\n    }\n\n    return -1;\n  }\n\n  return array.findIndex(predicate, thisArg);\n}\n\nfunction toArray(arg) {\n  if (!Array.from) {\n    return Array.prototype.slice.call(arg);\n  }\n\n  return Array.from(arg);\n}\n\nfunction includes(array, value) {\n  if (!Array.prototype.includes) {\n    for (var idx in array) {\n      if (array[idx] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return array.includes(value);\n}\n\nvar querySelector = function querySelector(arg, el) {\n  return (el || document).querySelectorAll(arg);\n};\n\nfunction getTag(tags, tag) {\n  if (!tags[tag]) {\n    tags[tag] = document.getElementsByTagName(tag)[0];\n  }\n\n  return tags[tag];\n}\n\nfunction getElementsKey(_ref) {\n  var body = _ref.body,\n      pbody = _ref.pbody;\n  return body ? 'body' : pbody ? 'pbody' : 'head';\n}\n\nfunction queryElements(parentNode, _ref2, attributes) {\n  var appId = _ref2.appId,\n      attribute = _ref2.attribute,\n      type = _ref2.type,\n      tagIDKeyName = _ref2.tagIDKeyName;\n  attributes = attributes || {};\n  var queries = [\"\".concat(type, \"[\").concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"), \"\".concat(type, \"[data-\").concat(tagIDKeyName, \"]\")].map(function (query) {\n    for (var key in attributes) {\n      var val = attributes[key];\n      var attributeValue = val && val !== true ? \"=\\\"\".concat(val, \"\\\"\") : '';\n      query += \"[data-\".concat(key).concat(attributeValue, \"]\");\n    }\n\n    return query;\n  });\n  return toArray(querySelector(queries.join(', '), parentNode));\n}\n\nfunction removeElementsByAppId(_ref3, appId) {\n  var attribute = _ref3.attribute;\n  toArray(querySelector(\"[\".concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"))).map(function (el) {\n    return el.remove();\n  });\n}\n\nfunction removeAttribute(el, attributeName) {\n  el.removeAttribute(attributeName);\n}\n\nfunction hasMetaInfo(vm) {\n  vm = vm || this;\n  return vm && (vm[rootConfigKey] === true || isObject(vm[rootConfigKey]));\n} // a component is in a metaInfo branch when itself has meta info or one of its (grand-)children has\n\n\nfunction inMetaInfoBranch(vm) {\n  vm = vm || this;\n  return vm && !isUndefined(vm[rootConfigKey]);\n}\n\nfunction pause(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = true;\n  return function () {\n    return resume(rootVm, refresh);\n  };\n}\n\nfunction resume(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = false;\n\n  if (refresh || refresh === undefined) {\n    return rootVm.$meta().refresh();\n  }\n}\n\nfunction addNavGuards(rootVm) {\n  var router = rootVm.$router; // return when nav guards already added or no router exists\n\n  if (rootVm[rootConfigKey].navGuards || !router) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  rootVm[rootConfigKey].navGuards = true;\n  router.beforeEach(function (to, from, next) {\n    pause(rootVm);\n    next();\n  });\n  router.afterEach(function () {\n    rootVm.$nextTick(function () {\n      var _resume = resume(rootVm),\n          metaInfo = _resume.metaInfo;\n\n      if (metaInfo && isFunction(metaInfo.afterNavigation)) {\n        metaInfo.afterNavigation(metaInfo);\n      }\n    });\n  });\n}\n\nvar appId = 1;\n\nfunction createMixin(Vue, options) {\n  // for which Vue lifecycle hooks should the metaInfo be refreshed\n  var updateOnLifecycleHook = ['activated', 'deactivated', 'beforeMount'];\n  var wasServerRendered = false; // watch for client side component updates\n\n  return {\n    beforeCreate: function beforeCreate() {\n      var _this2 = this;\n\n      var rootKey = '$root';\n      var $root = this[rootKey];\n      var $options = this.$options;\n      var devtoolsEnabled = Vue.config.devtools;\n      Object.defineProperty(this, '_hasMetaInfo', {\n        configurable: true,\n        get: function get() {\n          // Show deprecation warning once when devtools enabled\n          if (devtoolsEnabled && !$root[rootConfigKey].deprecationWarningShown) {\n            warn('VueMeta DeprecationWarning: _hasMetaInfo has been deprecated and will be removed in a future version. Please use hasMetaInfo(vm) instead');\n            $root[rootConfigKey].deprecationWarningShown = true;\n          }\n\n          return hasMetaInfo(this);\n        }\n      });\n\n      if (this === $root) {\n        $root.$once('hook:beforeMount', function () {\n          wasServerRendered = this.$el && this.$el.nodeType === 1 && this.$el.hasAttribute('data-server-rendered'); // In most cases when you have a SSR app it will be the first app thats gonna be\n          // initiated, if we cant detect the data-server-rendered attribute from Vue but we\n          // do see our own ssrAttribute then _assume_ the Vue app with appId 1 is the ssr app\n          // attempted fix for #404 & #562, but we rly need to refactor how we pass appIds from\n          // ssr to the client\n\n          if (!wasServerRendered && $root[rootConfigKey] && $root[rootConfigKey].appId === 1) {\n            var htmlTag = getTag({}, 'html');\n            wasServerRendered = htmlTag && htmlTag.hasAttribute(options.ssrAttribute);\n          }\n        });\n      } // Add a marker to know if it uses metaInfo\n      // _vnode is used to know that it's attached to a real component\n      // useful if we use some mixin to add some meta tags (like nuxt-i18n)\n\n\n      if (isUndefined($options[options.keyName]) || $options[options.keyName] === null) {\n        return;\n      }\n\n      if (!$root[rootConfigKey]) {\n        $root[rootConfigKey] = {\n          appId: appId\n        };\n        appId++;\n\n        if (devtoolsEnabled && $root.$options[options.keyName]) {\n          // use nextTick so the children should be added to $root\n          this.$nextTick(function () {\n            // find the first child that lists fnOptions\n            var child = find($root.$children, function (c) {\n              return c.$vnode && c.$vnode.fnOptions;\n            });\n\n            if (child && child.$vnode.fnOptions[options.keyName]) {\n              warn(\"VueMeta has detected a possible global mixin which adds a \".concat(options.keyName, \" property to all Vue components on the page. This could cause severe performance issues. If possible, use $meta().addApp to add meta information instead\"));\n            }\n          });\n        }\n      } // to speed up updates we keep track of branches which have a component with vue-meta info defined\n      // if _vueMeta = true it has info, if _vueMeta = false a child has info\n\n\n      if (!this[rootConfigKey]) {\n        this[rootConfigKey] = true;\n        var parent = this.$parent;\n\n        while (parent && parent !== $root) {\n          if (isUndefined(parent[rootConfigKey])) {\n            parent[rootConfigKey] = false;\n          }\n\n          parent = parent.$parent;\n        }\n      } // coerce function-style metaInfo to a computed prop so we can observe\n      // it on creation\n\n\n      if (isFunction($options[options.keyName])) {\n        $options.computed = $options.computed || {};\n        $options.computed.$metaInfo = $options[options.keyName];\n\n        if (!this.$isServer) {\n          // if computed $metaInfo exists, watch it for updates & trigger a refresh\n          // when it changes (i.e. automatically handle async actions that affect metaInfo)\n          // credit for this suggestion goes to [Sébastien Chopin](https://github.com/Atinux)\n          this.$on('hook:created', function () {\n            this.$watch('$metaInfo', function () {\n              triggerUpdate(options, this[rootKey], 'watcher');\n            });\n          });\n        }\n      } // force an initial refresh on page load and prevent other lifecycleHooks\n      // to triggerUpdate until this initial refresh is finished\n      // this is to make sure that when a page is opened in an inactive tab which\n      // has throttled rAF/timers we still immediately set the page title\n\n\n      if (isUndefined($root[rootConfigKey].initialized)) {\n        $root[rootConfigKey].initialized = this.$isServer;\n\n        if (!$root[rootConfigKey].initialized) {\n          if (!$root[rootConfigKey].initializedSsr) {\n            $root[rootConfigKey].initializedSsr = true;\n            this.$on('hook:beforeMount', function () {\n              var $root = this[rootKey]; // if this Vue-app was server rendered, set the appId to 'ssr'\n              // only one SSR app per page is supported\n\n              if (wasServerRendered) {\n                $root[rootConfigKey].appId = options.ssrAppId;\n              }\n            });\n          } // we use the mounted hook here as on page load\n\n\n          this.$on('hook:mounted', function () {\n            var $root = this[rootKey];\n\n            if ($root[rootConfigKey].initialized) {\n              return;\n            } // used in triggerUpdate to check if a change was triggered\n            // during initialization\n\n\n            $root[rootConfigKey].initializing = true; // refresh meta in nextTick so all child components have loaded\n\n            this.$nextTick(function () {\n              var _$root$$meta$refresh = $root.$meta().refresh(),\n                  tags = _$root$$meta$refresh.tags,\n                  metaInfo = _$root$$meta$refresh.metaInfo; // After ssr hydration (identifier by tags === false) check\n              // if initialized was set to null in triggerUpdate. That'd mean\n              // that during initilazation changes where triggered which need\n              // to be applied OR a metaInfo watcher was triggered before the\n              // current hook was called\n              // (during initialization all changes are blocked)\n\n\n              if (tags === false && $root[rootConfigKey].initialized === null) {\n                this.$nextTick(function () {\n                  return triggerUpdate(options, $root, 'init');\n                });\n              }\n\n              $root[rootConfigKey].initialized = true;\n              delete $root[rootConfigKey].initializing; // add the navigation guards if they havent been added yet\n              // they are needed for the afterNavigation callback\n\n              if (!options.refreshOnceOnNavigation && metaInfo.afterNavigation) {\n                addNavGuards($root);\n              }\n            });\n          }); // add the navigation guards if requested\n\n          if (options.refreshOnceOnNavigation) {\n            addNavGuards($root);\n          }\n        }\n      }\n\n      this.$on('hook:destroyed', function () {\n        var _this = this; // do not trigger refresh:\n        // - when user configured to not wait for transitions on destroyed\n        // - when the component doesnt have a parent\n        // - doesnt have metaInfo defined\n\n\n        if (!this.$parent || !hasMetaInfo(this)) {\n          return;\n        }\n\n        delete this._hasMetaInfo;\n        this.$nextTick(function () {\n          if (!options.waitOnDestroyed || !_this.$el || !_this.$el.offsetParent) {\n            triggerUpdate(options, _this.$root, 'destroyed');\n            return;\n          } // Wait that element is hidden before refreshing meta tags (to support animations)\n\n\n          var interval = setInterval(function () {\n            if (_this.$el && _this.$el.offsetParent !== null) {\n              /* istanbul ignore next line */\n              return;\n            }\n\n            clearInterval(interval);\n            triggerUpdate(options, _this.$root, 'destroyed');\n          }, 50);\n        });\n      }); // do not trigger refresh on the server side\n\n      if (this.$isServer) {\n        /* istanbul ignore next */\n        return;\n      } // no need to add this hooks on server side\n\n\n      updateOnLifecycleHook.forEach(function (lifecycleHook) {\n        _this2.$on(\"hook:\".concat(lifecycleHook), function () {\n          triggerUpdate(options, this[rootKey], lifecycleHook);\n        });\n      });\n    }\n  };\n}\n\nfunction setOptions(options) {\n  // combine options\n  options = isObject(options) ? options : {}; // The options are set like this so they can\n  // be minified by terser while keeping the\n  // user api intact\n  // terser --mangle-properties keep_quoted=strict\n\n  /* eslint-disable dot-notation */\n\n  return {\n    keyName: options['keyName'] || defaultOptions.keyName,\n    attribute: options['attribute'] || defaultOptions.attribute,\n    ssrAttribute: options['ssrAttribute'] || defaultOptions.ssrAttribute,\n    tagIDKeyName: options['tagIDKeyName'] || defaultOptions.tagIDKeyName,\n    contentKeyName: options['contentKeyName'] || defaultOptions.contentKeyName,\n    metaTemplateKeyName: options['metaTemplateKeyName'] || defaultOptions.metaTemplateKeyName,\n    debounceWait: isUndefined(options['debounceWait']) ? defaultOptions.debounceWait : options['debounceWait'],\n    waitOnDestroyed: isUndefined(options['waitOnDestroyed']) ? defaultOptions.waitOnDestroyed : options['waitOnDestroyed'],\n    ssrAppId: options['ssrAppId'] || defaultOptions.ssrAppId,\n    refreshOnceOnNavigation: !!options['refreshOnceOnNavigation']\n  };\n  /* eslint-enable dot-notation */\n}\n\nfunction getOptions(options) {\n  var optionsCopy = {};\n\n  for (var key in options) {\n    optionsCopy[key] = options[key];\n  }\n\n  return optionsCopy;\n}\n\nfunction ensureIsArray(arg, key) {\n  if (!key || !isObject(arg)) {\n    return isArray(arg) ? arg : [];\n  }\n\n  if (!isArray(arg[key])) {\n    arg[key] = [];\n  }\n\n  return arg;\n}\n\nvar serverSequences = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/\"/g, '&quot;'], [/'/g, '&#x27;']];\nvar clientSequences = [[/&/g, \"&\"], [/</g, \"<\"], [/>/g, \">\"], [/\"/g, \"\\\"\"], [/'/g, \"'\"]]; // sanitizes potentially dangerous characters\n\nfunction escape(info, options, escapeOptions, escapeKeys) {\n  var tagIDKeyName = options.tagIDKeyName;\n  var _escapeOptions$doEsca = escapeOptions.doEscape,\n      doEscape = _escapeOptions$doEsca === void 0 ? function (v) {\n    return v;\n  } : _escapeOptions$doEsca;\n  var escaped = {};\n\n  for (var key in info) {\n    var value = info[key]; // no need to escape configuration options\n\n    if (includes(metaInfoOptionKeys, key)) {\n      escaped[key] = value;\n      continue;\n    } // do not use destructuring for disableOptionKeys, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n\n\n    var disableKey = disableOptionKeys[0];\n\n    if (escapeOptions[disableKey] && includes(escapeOptions[disableKey], key)) {\n      // this info[key] doesnt need to escaped if the option is listed in __dangerouslyDisableSanitizers\n      escaped[key] = value;\n      continue;\n    }\n\n    var tagId = info[tagIDKeyName];\n\n    if (tagId) {\n      disableKey = disableOptionKeys[1]; // keys which are listed in __dangerouslyDisableSanitizersByTagID for the current vmid do not need to be escaped\n\n      if (escapeOptions[disableKey] && escapeOptions[disableKey][tagId] && includes(escapeOptions[disableKey][tagId], key)) {\n        escaped[key] = value;\n        continue;\n      }\n    }\n\n    if (isString(value)) {\n      escaped[key] = doEscape(value);\n    } else if (isArray(value)) {\n      escaped[key] = value.map(function (v) {\n        if (isPureObject(v)) {\n          return escape(v, options, escapeOptions, true);\n        }\n\n        return doEscape(v);\n      });\n    } else if (isPureObject(value)) {\n      escaped[key] = escape(value, options, escapeOptions, true);\n    } else {\n      escaped[key] = value;\n    }\n\n    if (escapeKeys) {\n      var escapedKey = doEscape(key);\n\n      if (key !== escapedKey) {\n        escaped[escapedKey] = escaped[key];\n        delete escaped[key];\n      }\n    }\n  }\n\n  return escaped;\n}\n\nfunction escapeMetaInfo(options, info, escapeSequences) {\n  escapeSequences = escapeSequences || []; // do not use destructuring for seq, it increases transpiled size\n  // due to var checks while we are guaranteed the structure of the cb\n\n  var escapeOptions = {\n    doEscape: function doEscape(value) {\n      return escapeSequences.reduce(function (val, seq) {\n        return val.replace(seq[0], seq[1]);\n      }, value);\n    }\n  };\n  disableOptionKeys.forEach(function (disableKey, index) {\n    if (index === 0) {\n      ensureIsArray(info, disableKey);\n    } else if (index === 1) {\n      for (var key in info[disableKey]) {\n        ensureIsArray(info[disableKey], key);\n      }\n    }\n\n    escapeOptions[disableKey] = info[disableKey];\n  }); // begin sanitization\n\n  return escape(info, options, escapeOptions);\n}\n\nfunction applyTemplate(_ref, headObject, template, chunk) {\n  var component = _ref.component,\n      metaTemplateKeyName = _ref.metaTemplateKeyName,\n      contentKeyName = _ref.contentKeyName;\n\n  if (template === true || headObject[metaTemplateKeyName] === true) {\n    // abort, template was already applied\n    return false;\n  }\n\n  if (isUndefined(template) && headObject[metaTemplateKeyName]) {\n    template = headObject[metaTemplateKeyName];\n    headObject[metaTemplateKeyName] = true;\n  } // return early if no template defined\n\n\n  if (!template) {\n    // cleanup faulty template properties\n    delete headObject[metaTemplateKeyName];\n    return false;\n  }\n\n  if (isUndefined(chunk)) {\n    chunk = headObject[contentKeyName];\n  }\n\n  headObject[contentKeyName] = isFunction(template) ? template.call(component, chunk) : template.replace(/%s/g, chunk);\n  return true;\n}\n\nfunction _arrayMerge(_ref, target, source) {\n  var component = _ref.component,\n      tagIDKeyName = _ref.tagIDKeyName,\n      metaTemplateKeyName = _ref.metaTemplateKeyName,\n      contentKeyName = _ref.contentKeyName; // we concat the arrays without merging objects contained in,\n  // but we check for a `vmid` property on each object in the array\n  // using an O(1) lookup associative array exploit\n\n  var destination = [];\n\n  if (!target.length && !source.length) {\n    return destination;\n  }\n\n  target.forEach(function (targetItem, targetIndex) {\n    // no tagID so no need to check for duplicity\n    if (!targetItem[tagIDKeyName]) {\n      destination.push(targetItem);\n      return;\n    }\n\n    var sourceIndex = findIndex(source, function (item) {\n      return item[tagIDKeyName] === targetItem[tagIDKeyName];\n    });\n    var sourceItem = source[sourceIndex]; // source doesnt contain any duplicate vmid's, we can keep targetItem\n\n    if (sourceIndex === -1) {\n      destination.push(targetItem);\n      return;\n    } // when sourceItem explictly defines contentKeyName or innerHTML as undefined, its\n    // an indication that we need to skip the default behaviour or child has preference over parent\n    // which means we keep the targetItem and ignore/remove the sourceItem\n\n\n    if (contentKeyName in sourceItem && sourceItem[contentKeyName] === undefined || 'innerHTML' in sourceItem && sourceItem.innerHTML === undefined) {\n      destination.push(targetItem); // remove current index from source array so its not concatenated to destination below\n\n      source.splice(sourceIndex, 1);\n      return;\n    } // we now know that targetItem is a duplicate and we should ignore it in favor of sourceItem\n    // if source specifies null as content then ignore both the target as the source\n\n\n    if (sourceItem[contentKeyName] === null || sourceItem.innerHTML === null) {\n      // remove current index from source array so its not concatenated to destination below\n      source.splice(sourceIndex, 1);\n      return;\n    } // now we only need to check if the target has a template to combine it with the source\n\n\n    var targetTemplate = targetItem[metaTemplateKeyName];\n\n    if (!targetTemplate) {\n      return;\n    }\n\n    var sourceTemplate = sourceItem[metaTemplateKeyName];\n\n    if (!sourceTemplate) {\n      // use parent template and child content\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, targetTemplate); // set template to true to indicate template was already applied\n\n      sourceItem.template = true;\n      return;\n    }\n\n    if (!sourceItem[contentKeyName]) {\n      // use parent content and child template\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, undefined, targetItem[contentKeyName]);\n    }\n  });\n  return destination.concat(source);\n}\n\nvar warningShown = false;\n\nfunction merge(target, source, options) {\n  options = options || {}; // remove properties explicitly set to false so child components can\n  // optionally _not_ overwrite the parents content\n  // (for array properties this is checked in arrayMerge)\n\n  if (source.title === undefined) {\n    delete source.title;\n  }\n\n  metaInfoAttributeKeys.forEach(function (attrKey) {\n    if (!source[attrKey]) {\n      return;\n    }\n\n    for (var key in source[attrKey]) {\n      if (key in source[attrKey] && source[attrKey][key] === undefined) {\n        if (includes(booleanHtmlAttributes, key) && !warningShown) {\n          warn('VueMeta: Please note that since v2 the value undefined is not used to indicate boolean attributes anymore, see migration guide for details');\n          warningShown = true;\n        }\n\n        delete source[attrKey][key];\n      }\n    }\n  });\n  return deepmerge(target, source, {\n    arrayMerge: function arrayMerge(t, s) {\n      return _arrayMerge(options, t, s);\n    }\n  });\n}\n\nfunction getComponentMetaInfo(options, component) {\n  return getComponentOption(options || {}, component, defaultInfo);\n}\n/**\n * Returns the `opts.option` $option value of the given `opts.component`.\n * If methods are encountered, they will be bound to the component context.\n * If `opts.deep` is true, will recursively merge all child component\n * `opts.option` $option values into the returned result.\n *\n * @param  {Object} opts - options\n * @param  {Object} opts.component - Vue component to fetch option data from\n * @param  {Boolean} opts.deep - look for data in child components as well?\n * @param  {Function} opts.arrayMerge - how should arrays be merged?\n * @param  {String} opts.keyName - the name of the option to look for\n * @param  {Object} [result={}] - result so far\n * @return {Object} result - final aggregated result\n */\n\n\nfunction getComponentOption(options, component, result) {\n  result = result || {};\n\n  if (component._inactive) {\n    return result;\n  }\n\n  options = options || {};\n  var _options = options,\n      keyName = _options.keyName;\n  var $metaInfo = component.$metaInfo,\n      $options = component.$options,\n      $children = component.$children; // only collect option data if it exists\n\n  if ($options[keyName]) {\n    // if $metaInfo exists then [keyName] was defined as a function\n    // and set to the computed prop $metaInfo in the mixin\n    // using the computed prop should be a small performance increase\n    // because Vue caches those internally\n    var data = $metaInfo || $options[keyName]; // only merge data with result when its an object\n    // eg it could be a function when metaInfo() returns undefined\n    // dueo to the or statement above\n\n    if (isObject(data)) {\n      result = merge(result, data, options);\n    }\n  } // collect & aggregate child options if deep = true\n\n\n  if ($children.length) {\n    $children.forEach(function (childComponent) {\n      // check if the childComponent is in a branch\n      // return otherwise so we dont walk all component branches unnecessarily\n      if (!inMetaInfoBranch(childComponent)) {\n        return;\n      }\n\n      result = getComponentOption(options, childComponent, result);\n    });\n  }\n\n  return result;\n}\n\nvar callbacks = [];\n\nfunction isDOMComplete(d) {\n  return (d || document).readyState === 'complete';\n}\n\nfunction addCallback(query, callback) {\n  if (arguments.length === 1) {\n    callback = query;\n    query = '';\n  }\n\n  callbacks.push([query, callback]);\n}\n\nfunction addCallbacks(_ref, type, tags, autoAddListeners) {\n  var tagIDKeyName = _ref.tagIDKeyName;\n  var hasAsyncCallback = false;\n  tags.forEach(function (tag) {\n    if (!tag[tagIDKeyName] || !tag.callback) {\n      return;\n    }\n\n    hasAsyncCallback = true;\n    addCallback(\"\".concat(type, \"[data-\").concat(tagIDKeyName, \"=\\\"\").concat(tag[tagIDKeyName], \"\\\"]\"), tag.callback);\n  });\n\n  if (!autoAddListeners || !hasAsyncCallback) {\n    return hasAsyncCallback;\n  }\n\n  return addListeners();\n}\n\nfunction addListeners() {\n  if (isDOMComplete()) {\n    applyCallbacks();\n    return;\n  } // Instead of using a MutationObserver, we just apply\n\n  /* istanbul ignore next */\n\n\n  document.onreadystatechange = function () {\n    applyCallbacks();\n  };\n}\n\nfunction applyCallbacks(matchElement) {\n  callbacks.forEach(function (args) {\n    // do not use destructuring for args, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n    var query = args[0];\n    var callback = args[1];\n    var selector = \"\".concat(query, \"[onload=\\\"this.__vm_l=1\\\"]\");\n    var elements = [];\n\n    if (!matchElement) {\n      elements = toArray(querySelector(selector));\n    }\n\n    if (matchElement && matchElement.matches(selector)) {\n      elements = [matchElement];\n    }\n\n    elements.forEach(function (element) {\n      /* __vm_cb: whether the load callback has been called\n       * __vm_l: set by onload attribute, whether the element was loaded\n       * __vm_ev: whether the event listener was added or not\n       */\n      if (element.__vm_cb) {\n        return;\n      }\n\n      var onload = function onload() {\n        /* Mark that the callback for this element has already been called,\n         * this prevents the callback to run twice in some (rare) conditions\n         */\n        element.__vm_cb = true;\n        /* onload needs to be removed because we only need the\n         * attribute after ssr and if we dont remove it the node\n         * will fail isEqualNode on the client\n         */\n\n        removeAttribute(element, 'onload');\n        callback(element);\n      };\n      /* IE9 doesnt seem to load scripts synchronously,\n       * causing a script sometimes/often already to be loaded\n       * when we add the event listener below (thus adding an onload event\n       * listener has no use because it will never be triggered).\n       * Therefore we add the onload attribute during ssr, and\n       * check here if it was already loaded or not\n       */\n\n\n      if (element.__vm_l) {\n        onload();\n        return;\n      }\n\n      if (!element.__vm_ev) {\n        element.__vm_ev = true;\n        element.addEventListener('load', onload);\n      }\n    });\n  });\n} // instead of adding it to the html\n\n\nvar attributeMap = {};\n/**\n * Updates the document's html tag attributes\n *\n * @param  {Object} attrs - the new document html attributes\n * @param  {HTMLElement} tag - the HTMLElement tag to update with new attrs\n */\n\nfunction updateAttribute(appId, options, type, attrs, tag) {\n  var _ref = options || {},\n      attribute = _ref.attribute;\n\n  var vueMetaAttrString = tag.getAttribute(attribute);\n\n  if (vueMetaAttrString) {\n    attributeMap[type] = JSON.parse(decodeURI(vueMetaAttrString));\n    removeAttribute(tag, attribute);\n  }\n\n  var data = attributeMap[type] || {};\n  var toUpdate = []; // remove attributes from the map\n  // which have been removed for this appId\n\n  for (var attr in data) {\n    if (data[attr] !== undefined && appId in data[attr]) {\n      toUpdate.push(attr);\n\n      if (!attrs[attr]) {\n        delete data[attr][appId];\n      }\n    }\n  }\n\n  for (var _attr in attrs) {\n    var attrData = data[_attr];\n\n    if (!attrData || attrData[appId] !== attrs[_attr]) {\n      toUpdate.push(_attr);\n\n      if (attrs[_attr] !== undefined) {\n        data[_attr] = data[_attr] || {};\n        data[_attr][appId] = attrs[_attr];\n      }\n    }\n  }\n\n  for (var _i = 0, _toUpdate = toUpdate; _i < _toUpdate.length; _i++) {\n    var _attr2 = _toUpdate[_i];\n    var _attrData = data[_attr2];\n    var attrValues = [];\n\n    for (var _appId in _attrData) {\n      Array.prototype.push.apply(attrValues, [].concat(_attrData[_appId]));\n    }\n\n    if (attrValues.length) {\n      var attrValue = includes(booleanHtmlAttributes, _attr2) && attrValues.some(Boolean) ? '' : attrValues.filter(function (v) {\n        return v !== undefined;\n      }).join(' ');\n      tag.setAttribute(_attr2, attrValue);\n    } else {\n      removeAttribute(tag, _attr2);\n    }\n  }\n\n  attributeMap[type] = data;\n}\n/**\n * Updates the document title\n *\n * @param  {String} title - the new title of the document\n */\n\n\nfunction updateTitle(title) {\n  if (!title && title !== '') {\n    return;\n  }\n\n  document.title = title;\n}\n/**\n * Updates meta tags inside <head> and <body> on the client. Borrowed from `react-helmet`:\n * https://github.com/nfl/react-helmet/blob/004d448f8de5f823d10f838b02317521180f34da/src/Helmet.js#L195-L245\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} type - the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - a representation of what tags changed\n */\n\n\nfunction updateTag(appId, options, type, tags, head, body) {\n  var _ref = options || {},\n      attribute = _ref.attribute,\n      tagIDKeyName = _ref.tagIDKeyName;\n\n  var dataAttributes = commonDataAttributes.slice();\n  dataAttributes.push(tagIDKeyName);\n  var newElements = [];\n  var queryOptions = {\n    appId: appId,\n    attribute: attribute,\n    type: type,\n    tagIDKeyName: tagIDKeyName\n  };\n  var currentElements = {\n    head: queryElements(head, queryOptions),\n    pbody: queryElements(body, queryOptions, {\n      pbody: true\n    }),\n    body: queryElements(body, queryOptions, {\n      body: true\n    })\n  };\n\n  if (tags.length > 1) {\n    // remove duplicates that could have been found by merging tags\n    // which include a mixin with metaInfo and that mixin is used\n    // by multiple components on the same page\n    var found = [];\n    tags = tags.filter(function (x) {\n      var k = JSON.stringify(x);\n      var res = !includes(found, k);\n      found.push(k);\n      return res;\n    });\n  }\n\n  tags.forEach(function (tag) {\n    if (tag.skip) {\n      return;\n    }\n\n    var newElement = document.createElement(type);\n\n    if (!tag.once) {\n      newElement.setAttribute(attribute, appId);\n    }\n\n    Object.keys(tag).forEach(function (attr) {\n      /* istanbul ignore next */\n      if (includes(tagProperties, attr)) {\n        return;\n      }\n\n      if (attr === 'innerHTML') {\n        newElement.innerHTML = tag.innerHTML;\n        return;\n      }\n\n      if (attr === 'json') {\n        newElement.innerHTML = JSON.stringify(tag.json);\n        return;\n      }\n\n      if (attr === 'cssText') {\n        if (newElement.styleSheet) {\n          /* istanbul ignore next */\n          newElement.styleSheet.cssText = tag.cssText;\n        } else {\n          newElement.appendChild(document.createTextNode(tag.cssText));\n        }\n\n        return;\n      }\n\n      if (attr === 'callback') {\n        newElement.onload = function () {\n          return tag[attr](newElement);\n        };\n\n        return;\n      }\n\n      var _attr = includes(dataAttributes, attr) ? \"data-\".concat(attr) : attr;\n\n      var isBooleanAttribute = includes(booleanHtmlAttributes, attr);\n\n      if (isBooleanAttribute && !tag[attr]) {\n        return;\n      }\n\n      var value = isBooleanAttribute ? '' : tag[attr];\n      newElement.setAttribute(_attr, value);\n    });\n    var oldElements = currentElements[getElementsKey(tag)]; // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.\n\n    var indexToDelete;\n    var hasEqualElement = oldElements.some(function (existingTag, index) {\n      indexToDelete = index;\n      return newElement.isEqualNode(existingTag);\n    });\n\n    if (hasEqualElement && (indexToDelete || indexToDelete === 0)) {\n      oldElements.splice(indexToDelete, 1);\n    } else {\n      newElements.push(newElement);\n    }\n  });\n  var oldElements = [];\n\n  for (var _type in currentElements) {\n    Array.prototype.push.apply(oldElements, currentElements[_type]);\n  } // remove old elements\n\n\n  oldElements.forEach(function (element) {\n    element.parentNode.removeChild(element);\n  }); // insert new elements\n\n  newElements.forEach(function (element) {\n    if (element.hasAttribute('data-body')) {\n      body.appendChild(element);\n      return;\n    }\n\n    if (element.hasAttribute('data-pbody')) {\n      body.insertBefore(element, body.firstChild);\n      return;\n    }\n\n    head.appendChild(element);\n  });\n  return {\n    oldTags: oldElements,\n    newTags: newElements\n  };\n}\n/**\n * Performs client-side updates when new meta info is received\n *\n * @param  {Object} newInfo - the meta info to update to\n */\n\n\nfunction updateClientMetaInfo(appId, options, newInfo) {\n  options = options || {};\n  var _options = options,\n      ssrAttribute = _options.ssrAttribute,\n      ssrAppId = _options.ssrAppId; // only cache tags for current update\n\n  var tags = {};\n  var htmlTag = getTag(tags, 'html'); // if this is a server render, then dont update\n\n  if (appId === ssrAppId && htmlTag.hasAttribute(ssrAttribute)) {\n    // remove the server render attribute so we can update on (next) changes\n    removeAttribute(htmlTag, ssrAttribute); // add load callbacks if the\n\n    var addLoadListeners = false;\n    tagsSupportingOnload.forEach(function (type) {\n      if (newInfo[type] && addCallbacks(options, type, newInfo[type])) {\n        addLoadListeners = true;\n      }\n    });\n\n    if (addLoadListeners) {\n      addListeners();\n    }\n\n    return false;\n  } // initialize tracked changes\n\n\n  var tagsAdded = {};\n  var tagsRemoved = {};\n\n  for (var type in newInfo) {\n    // ignore these\n    if (includes(metaInfoOptionKeys, type)) {\n      continue;\n    }\n\n    if (type === 'title') {\n      // update the title\n      updateTitle(newInfo.title);\n      continue;\n    }\n\n    if (includes(metaInfoAttributeKeys, type)) {\n      var tagName = type.substr(0, 4);\n      updateAttribute(appId, options, type, newInfo[type], getTag(tags, tagName));\n      continue;\n    } // tags should always be an array, ignore if it isnt\n\n\n    if (!isArray(newInfo[type])) {\n      continue;\n    }\n\n    var _updateTag = updateTag(appId, options, type, newInfo[type], getTag(tags, 'head'), getTag(tags, 'body')),\n        oldTags = _updateTag.oldTags,\n        newTags = _updateTag.newTags;\n\n    if (newTags.length) {\n      tagsAdded[type] = newTags;\n      tagsRemoved[type] = oldTags;\n    }\n  }\n\n  return {\n    tagsAdded: tagsAdded,\n    tagsRemoved: tagsRemoved\n  };\n}\n\nvar appsMetaInfo;\n\nfunction addApp(rootVm, appId, options) {\n  return {\n    set: function set(metaInfo) {\n      return setMetaInfo(rootVm, appId, options, metaInfo);\n    },\n    remove: function remove() {\n      return removeMetaInfo(rootVm, appId, options);\n    }\n  };\n}\n\nfunction setMetaInfo(rootVm, appId, options, metaInfo) {\n  // if a vm exists _and_ its mounted then immediately update\n  if (rootVm && rootVm.$el) {\n    return updateClientMetaInfo(appId, options, metaInfo);\n  } // store for later, the info\n  // will be set on the first refresh\n\n\n  appsMetaInfo = appsMetaInfo || {};\n  appsMetaInfo[appId] = metaInfo;\n}\n\nfunction removeMetaInfo(rootVm, appId, options) {\n  if (rootVm && rootVm.$el) {\n    var tags = {};\n\n    var _iterator = _createForOfIteratorHelper(metaInfoAttributeKeys),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n        var tagName = type.substr(0, 4);\n        updateAttribute(appId, options, type, {}, getTag(tags, tagName));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return removeElementsByAppId(options, appId);\n  }\n\n  if (appsMetaInfo[appId]) {\n    delete appsMetaInfo[appId];\n    clearAppsMetaInfo();\n  }\n}\n\nfunction getAppsMetaInfo() {\n  return appsMetaInfo;\n}\n\nfunction clearAppsMetaInfo(force) {\n  if (force || !Object.keys(appsMetaInfo).length) {\n    appsMetaInfo = undefined;\n  }\n}\n/**\n * Returns the correct meta info for the given component\n * (child components will overwrite parent meta info)\n *\n * @param  {Object} component - the Vue instance to get meta info from\n * @return {Object} - returned meta info\n */\n\n\nfunction getMetaInfo(options, info, escapeSequences, component) {\n  options = options || {};\n  escapeSequences = escapeSequences || [];\n  var _options = options,\n      tagIDKeyName = _options.tagIDKeyName; // Remove all \"template\" tags from meta\n  // backup the title chunk in case user wants access to it\n\n  if (info.title) {\n    info.titleChunk = info.title;\n  } // replace title with populated template\n\n\n  if (info.titleTemplate && info.titleTemplate !== '%s') {\n    applyTemplate({\n      component: component,\n      contentKeyName: 'title'\n    }, info, info.titleTemplate, info.titleChunk || '');\n  } // convert base tag to an array so it can be handled the same way\n  // as the other tags\n\n\n  if (info.base) {\n    info.base = Object.keys(info.base).length ? [info.base] : [];\n  }\n\n  if (info.meta) {\n    // remove meta items with duplicate vmid's\n    info.meta = info.meta.filter(function (metaItem, index, arr) {\n      var hasVmid = !!metaItem[tagIDKeyName];\n\n      if (!hasVmid) {\n        return true;\n      }\n\n      var isFirstItemForVmid = index === findIndex(arr, function (item) {\n        return item[tagIDKeyName] === metaItem[tagIDKeyName];\n      });\n      return isFirstItemForVmid;\n    }); // apply templates if needed\n\n    info.meta.forEach(function (metaObject) {\n      return applyTemplate(options, metaObject);\n    });\n  }\n\n  return escapeMetaInfo(options, info, escapeSequences);\n}\n/**\n * When called, will update the current meta info with new meta info.\n * Useful when updating meta info as the result of an asynchronous\n * action that resolves after the initial render takes place.\n *\n * Credit to [Sébastien Chopin](https://github.com/Atinux) for the suggestion\n * to implement this method.\n *\n * @return {Object} - new meta info\n */\n\n\nfunction refresh(rootVm, options) {\n  options = options || {}; // make sure vue-meta was initiated\n\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, clientSequences, rootVm);\n  var appId = rootVm[rootConfigKey].appId;\n  var tags = updateClientMetaInfo(appId, options, metaInfo); // emit \"event\" with new info\n\n  if (tags && isFunction(metaInfo.changed)) {\n    metaInfo.changed(metaInfo, tags.tagsAdded, tags.tagsRemoved);\n    tags = {\n      addedTags: tags.tagsAdded,\n      removedTags: tags.tagsRemoved\n    };\n  }\n\n  var appsMetaInfo = getAppsMetaInfo();\n\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      updateClientMetaInfo(additionalAppId, options, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n\n    clearAppsMetaInfo(true);\n  }\n\n  return {\n    vm: rootVm,\n    metaInfo: metaInfo,\n    // eslint-disable-line object-shorthand\n    tags: tags\n  };\n}\n/**\n * Generates tag attributes for use on the server.\n *\n * @param  {('bodyAttrs'|'htmlAttrs'|'headAttrs')} type - the type of attributes to generate\n * @param  {Object} data - the attributes to generate\n * @return {Object} - the attribute generator\n */\n\n\nfunction attributeGenerator(options, type, data, _ref) {\n  var addSsrAttribute = _ref.addSsrAttribute;\n\n  var _ref2 = options || {},\n      attribute = _ref2.attribute,\n      ssrAttribute = _ref2.ssrAttribute;\n\n  var attributeStr = '';\n\n  for (var attr in data) {\n    var attrData = data[attr];\n    var attrValues = [];\n\n    for (var appId in attrData) {\n      attrValues.push.apply(attrValues, _toConsumableArray([].concat(attrData[appId])));\n    }\n\n    if (attrValues.length) {\n      attributeStr += booleanHtmlAttributes.includes(attr) && attrValues.some(Boolean) ? \"\".concat(attr) : \"\".concat(attr, \"=\\\"\").concat(attrValues.join(' '), \"\\\"\");\n      attributeStr += ' ';\n    }\n  }\n\n  if (attributeStr) {\n    attributeStr += \"\".concat(attribute, \"=\\\"\").concat(encodeURI(JSON.stringify(data)), \"\\\"\");\n  }\n\n  if (type === 'htmlAttrs' && addSsrAttribute) {\n    return \"\".concat(ssrAttribute).concat(attributeStr ? ' ' : '').concat(attributeStr);\n  }\n\n  return attributeStr;\n}\n/**\n * Generates title output for the server\n *\n * @param  {'title'} type - the string \"title\"\n * @param  {String} data - the title text\n * @return {Object} - the title generator\n */\n\n\nfunction titleGenerator(options, type, data, generatorOptions) {\n  var _ref = generatorOptions || {},\n      ln = _ref.ln;\n\n  if (!data) {\n    return '';\n  }\n\n  return \"<\".concat(type, \">\").concat(data, \"</\").concat(type, \">\").concat(ln ? '\\n' : '');\n}\n/**\n * Generates meta, base, link, style, script, noscript tags for use on the server\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - the tag generator\n */\n\n\nfunction tagGenerator(options, type, tags, generatorOptions) {\n  var _ref = options || {},\n      ssrAppId = _ref.ssrAppId,\n      attribute = _ref.attribute,\n      tagIDKeyName = _ref.tagIDKeyName;\n\n  var _ref2 = generatorOptions || {},\n      appId = _ref2.appId,\n      _ref2$isSSR = _ref2.isSSR,\n      isSSR = _ref2$isSSR === void 0 ? true : _ref2$isSSR,\n      _ref2$body = _ref2.body,\n      body = _ref2$body === void 0 ? false : _ref2$body,\n      _ref2$pbody = _ref2.pbody,\n      pbody = _ref2$pbody === void 0 ? false : _ref2$pbody,\n      _ref2$ln = _ref2.ln,\n      ln = _ref2$ln === void 0 ? false : _ref2$ln;\n\n  var dataAttributes = [tagIDKeyName].concat(_toConsumableArray(commonDataAttributes));\n\n  if (!tags || !tags.length) {\n    return '';\n  } // build a string containing all tags of this type\n\n\n  return tags.reduce(function (tagsStr, tag) {\n    if (tag.skip) {\n      return tagsStr;\n    }\n\n    var tagKeys = Object.keys(tag);\n\n    if (tagKeys.length === 0) {\n      return tagsStr; // Bail on empty tag object\n    }\n\n    if (Boolean(tag.body) !== body || Boolean(tag.pbody) !== pbody) {\n      return tagsStr;\n    }\n\n    var attrs = tag.once ? '' : \" \".concat(attribute, \"=\\\"\").concat(appId || (isSSR === false ? '1' : ssrAppId), \"\\\"\"); // build a string containing all attributes of this tag\n\n    for (var attr in tag) {\n      // these attributes are treated as children on the tag\n      if (tagAttributeAsInnerContent.includes(attr) || tagProperties.includes(attr)) {\n        continue;\n      }\n\n      if (attr === 'callback') {\n        attrs += ' onload=\"this.__vm_l=1\"';\n        continue;\n      } // these form the attribute list for this tag\n\n\n      var prefix = '';\n\n      if (dataAttributes.includes(attr)) {\n        prefix = 'data-';\n      }\n\n      var isBooleanAttr = !prefix && booleanHtmlAttributes.includes(attr);\n\n      if (isBooleanAttr && !tag[attr]) {\n        continue;\n      }\n\n      attrs += \" \".concat(prefix).concat(attr) + (isBooleanAttr ? '' : \"=\\\"\".concat(tag[attr], \"\\\"\"));\n    }\n\n    var json = '';\n\n    if (tag.json) {\n      json = JSON.stringify(tag.json);\n    } // grab child content from one of these attributes, if possible\n\n\n    var content = tag.innerHTML || tag.cssText || json; // generate tag exactly without any other redundant attribute\n    // these tags have no end tag\n\n    var hasEndTag = !tagsWithoutEndTag.includes(type); // these tag types will have content inserted\n\n    var hasContent = hasEndTag && tagsWithInnerContent.includes(type); // the final string for this specific tag\n\n    return \"\".concat(tagsStr, \"<\").concat(type).concat(attrs).concat(!hasContent && hasEndTag ? '/' : '', \">\") + (hasContent ? \"\".concat(content, \"</\").concat(type, \">\") : '') + (ln ? '\\n' : '');\n  }, '');\n}\n/**\n * Converts a meta info property to one that can be stringified on the server\n *\n * @param  {String} type - the type of data to convert\n * @param  {(String|Object|Array<Object>)} data - the data value\n * @return {Object} - the new injector\n */\n\n\nfunction generateServerInjector(options, metaInfo, globalInjectOptions) {\n  var serverInjector = {\n    data: metaInfo,\n    extraData: undefined,\n    addInfo: function addInfo(appId, metaInfo) {\n      this.extraData = this.extraData || {};\n      this.extraData[appId] = metaInfo;\n    },\n    callInjectors: function callInjectors(opts) {\n      var m = this.injectors; // only call title for the head\n\n      return (opts.body || opts.pbody ? '' : m.title.text(opts)) + m.meta.text(opts) + m.base.text(opts) + m.link.text(opts) + m.style.text(opts) + m.script.text(opts) + m.noscript.text(opts);\n    },\n    injectors: {\n      head: function head(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln\n        }));\n      },\n      bodyPrepend: function bodyPrepend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          pbody: true\n        }));\n      },\n      bodyAppend: function bodyAppend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          body: true\n        }));\n      }\n    }\n  };\n\n  var _loop = function _loop(type) {\n    if (metaInfoOptionKeys.includes(type)) {\n      return \"continue\";\n    }\n\n    serverInjector.injectors[type] = {\n      text: function text(injectOptions) {\n        var addSsrAttribute = injectOptions === true;\n        injectOptions = _objectSpread2(_objectSpread2({\n          addSsrAttribute: addSsrAttribute\n        }, globalInjectOptions), injectOptions);\n\n        if (type === 'title') {\n          return titleGenerator(options, type, serverInjector.data[type], injectOptions);\n        }\n\n        if (metaInfoAttributeKeys.includes(type)) {\n          var attributeData = {};\n          var data = serverInjector.data[type];\n\n          if (data) {\n            var appId = injectOptions.isSSR === false ? '1' : options.ssrAppId;\n\n            for (var attr in data) {\n              attributeData[attr] = _defineProperty({}, appId, data[attr]);\n            }\n          }\n\n          if (serverInjector.extraData) {\n            for (var _appId in serverInjector.extraData) {\n              var _data = serverInjector.extraData[_appId][type];\n\n              if (_data) {\n                for (var _attr in _data) {\n                  attributeData[_attr] = _objectSpread2(_objectSpread2({}, attributeData[_attr]), {}, _defineProperty({}, _appId, _data[_attr]));\n                }\n              }\n            }\n          }\n\n          return attributeGenerator(options, type, attributeData, injectOptions);\n        }\n\n        var str = tagGenerator(options, type, serverInjector.data[type], injectOptions);\n\n        if (serverInjector.extraData) {\n          for (var _appId2 in serverInjector.extraData) {\n            var _data2 = serverInjector.extraData[_appId2][type];\n            var extraStr = tagGenerator(options, type, _data2, _objectSpread2({\n              appId: _appId2\n            }, injectOptions));\n            str = \"\".concat(str).concat(extraStr);\n          }\n        }\n\n        return str;\n      }\n    };\n  };\n\n  for (var type in defaultInfo) {\n    var _ret = _loop(type);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return serverInjector;\n}\n/**\n * Converts the state of the meta info object such that each item\n * can be compiled to a tag string on the server\n *\n * @vm {Object} - Vue instance - ideally the root component\n * @return {Object} - server meta info with `toString` methods\n */\n\n\nfunction inject(rootVm, options, injectOptions) {\n  // make sure vue-meta was initiated\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences, rootVm); // generate server injector\n\n  var serverInjector = generateServerInjector(options, metaInfo, injectOptions); // add meta info from additional apps\n\n  var appsMetaInfo = getAppsMetaInfo();\n\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      serverInjector.addInfo(additionalAppId, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n\n    clearAppsMetaInfo(true);\n  }\n\n  return serverInjector.injectors;\n}\n\nfunction $meta(options) {\n  options = options || {};\n  /**\n   * Returns an injector for server-side rendering.\n   * @this {Object} - the Vue instance (a root component)\n   * @return {Object} - injector\n   */\n\n  var $root = this.$root;\n  return {\n    getOptions: function getOptions$1() {\n      return getOptions(options);\n    },\n    setOptions: function setOptions(newOptions) {\n      var refreshNavKey = 'refreshOnceOnNavigation';\n\n      if (newOptions && newOptions[refreshNavKey]) {\n        options.refreshOnceOnNavigation = !!newOptions[refreshNavKey];\n        addNavGuards($root);\n      }\n\n      var debounceWaitKey = 'debounceWait';\n\n      if (newOptions && debounceWaitKey in newOptions) {\n        var debounceWait = parseInt(newOptions[debounceWaitKey]);\n\n        if (!isNaN(debounceWait)) {\n          options.debounceWait = debounceWait;\n        }\n      }\n\n      var waitOnDestroyedKey = 'waitOnDestroyed';\n\n      if (newOptions && waitOnDestroyedKey in newOptions) {\n        options.waitOnDestroyed = !!newOptions[waitOnDestroyedKey];\n      }\n    },\n    refresh: function refresh$1() {\n      return refresh($root, options);\n    },\n    inject: function inject$1(injectOptions) {\n      return inject($root, options, injectOptions);\n    },\n    pause: function pause$1() {\n      return pause($root);\n    },\n    resume: function resume$1() {\n      return resume($root);\n    },\n    addApp: function addApp$1(appId) {\n      return addApp($root, appId, options);\n    }\n  };\n}\n\nfunction generate(rawInfo, options) {\n  options = setOptions(options);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences);\n  var serverInjector = generateServerInjector(options, metaInfo);\n  return serverInjector.injectors;\n}\n/**\n * Plugin install function.\n * @param {Function} Vue - the Vue constructor.\n */\n\n\nfunction install(Vue, options) {\n  if (Vue.__vuemeta_installed) {\n    return;\n  }\n\n  Vue.__vuemeta_installed = true;\n  options = setOptions(options);\n\n  Vue.prototype.$meta = function () {\n    return $meta.call(this, options);\n  };\n\n  Vue.mixin(createMixin(Vue, options));\n}\n\nvar index = {\n  version: version,\n  install: install,\n  generate: function generate$1(metaInfo, options) {\n    return generate(metaInfo, options);\n  },\n  hasMetaInfo: hasMetaInfo\n};\nexport default index;","map":{"version":3,"sources":["/Users/mac/Documents/source-code/source-js/my_portofolio/node_modules/vue-meta/dist/vue-meta.esm.js"],"names":["deepmerge","version","_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperty","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","from","o","minLen","n","toString","call","slice","name","test","len","arr2","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","done","e","f","normalCompletion","didErr","err","step","next","return","arg","isUndefined","isObject","isPureObject","isFunction","isString","hasGlobalWindowFn","window","hasGlobalWindow","_global","global","console","warn","str","showWarningNotSupported","defaultInfo","title","undefined","titleChunk","titleTemplate","htmlAttrs","bodyAttrs","headAttrs","base","link","meta","style","script","noscript","__dangerouslyDisableSanitizers","__dangerouslyDisableSanitizersByTagID","rootConfigKey","keyName","attribute","ssrAttribute","tagIDKeyName","metaTemplateKeyName","contentKeyName","ssrAppId","debounceWait","waitOnDestroyed","defaultOptions","defaultInfoKeys","disableOptionKeys","metaInfoOptionKeys","concat","metaInfoAttributeKeys","tagsSupportingOnload","tagsWithoutEndTag","tagsWithInnerContent","tagAttributeAsInnerContent","tagProperties","commonDataAttributes","booleanHtmlAttributes","batchId","triggerUpdate","_ref","rootVm","hookName","initialized","initializing","pausing","batchUpdate","$meta","refresh","callback","timeout","clearTimeout","setTimeout","find","array","predicate","thisArg","idx","findIndex","toArray","includes","querySelector","el","document","querySelectorAll","getTag","tags","tag","getElementsByTagName","getElementsKey","body","pbody","queryElements","parentNode","_ref2","attributes","appId","type","queries","map","query","val","attributeValue","join","removeElementsByAppId","_ref3","remove","removeAttribute","attributeName","hasMetaInfo","vm","inMetaInfoBranch","pause","resume","addNavGuards","router","$router","navGuards","beforeEach","to","afterEach","$nextTick","_resume","metaInfo","afterNavigation","createMixin","Vue","options","updateOnLifecycleHook","wasServerRendered","beforeCreate","_this2","rootKey","$root","$options","devtoolsEnabled","config","devtools","get","deprecationWarningShown","$once","$el","nodeType","hasAttribute","htmlTag","child","$children","c","$vnode","fnOptions","parent","$parent","computed","$metaInfo","$isServer","$on","$watch","initializedSsr","_$root$$meta$refresh","refreshOnceOnNavigation","_this","_hasMetaInfo","offsetParent","interval","setInterval","clearInterval","lifecycleHook","setOptions","getOptions","optionsCopy","ensureIsArray","serverSequences","clientSequences","escape","info","escapeOptions","escapeKeys","_escapeOptions$doEsca","doEscape","v","escaped","disableKey","tagId","escapedKey","escapeMetaInfo","escapeSequences","reduce","seq","replace","index","applyTemplate","headObject","template","chunk","component","_arrayMerge","destination","targetItem","targetIndex","sourceIndex","item","sourceItem","innerHTML","splice","targetTemplate","sourceTemplate","warningShown","merge","attrKey","arrayMerge","t","getComponentMetaInfo","getComponentOption","result","_inactive","_options","data","childComponent","callbacks","isDOMComplete","d","readyState","addCallback","addCallbacks","autoAddListeners","hasAsyncCallback","addListeners","applyCallbacks","onreadystatechange","matchElement","args","selector","elements","matches","element","__vm_cb","onload","__vm_l","__vm_ev","addEventListener","attributeMap","updateAttribute","attrs","vueMetaAttrString","getAttribute","JSON","parse","decodeURI","toUpdate","attr","_attr","attrData","_i","_toUpdate","_attr2","_attrData","attrValues","_appId","attrValue","some","Boolean","setAttribute","updateTitle","updateTag","head","dataAttributes","newElements","queryOptions","currentElements","found","x","k","stringify","res","skip","newElement","createElement","once","json","styleSheet","cssText","appendChild","createTextNode","isBooleanAttribute","oldElements","indexToDelete","hasEqualElement","existingTag","isEqualNode","_type","removeChild","insertBefore","firstChild","oldTags","newTags","updateClientMetaInfo","newInfo","addLoadListeners","tagsAdded","tagsRemoved","tagName","substr","_updateTag","appsMetaInfo","addApp","set","setMetaInfo","removeMetaInfo","_iterator","_step","clearAppsMetaInfo","getAppsMetaInfo","force","getMetaInfo","metaItem","hasVmid","isFirstItemForVmid","metaObject","rawInfo","changed","addedTags","removedTags","additionalAppId","attributeGenerator","addSsrAttribute","attributeStr","encodeURI","titleGenerator","generatorOptions","ln","tagGenerator","_ref2$isSSR","isSSR","_ref2$body","_ref2$pbody","_ref2$ln","tagsStr","tagKeys","prefix","isBooleanAttr","content","hasEndTag","hasContent","generateServerInjector","globalInjectOptions","serverInjector","extraData","addInfo","callInjectors","opts","m","injectors","text","bodyPrepend","bodyAppend","_loop","injectOptions","attributeData","_data","_appId2","_data2","extraStr","_ret","inject","getOptions$1","newOptions","refreshNavKey","debounceWaitKey","parseInt","isNaN","waitOnDestroyedKey","refresh$1","inject$1","pause$1","resume$1","addApp$1","generate","install","__vuemeta_installed","mixin","generate$1"],"mappings":"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","sourcesContent":["/**\n * vue-meta v2.4.0\n * (c) 2020\n * - Declan de Wet\n * - Sébastien Chopin (@Atinux)\n * - Pim (@pimlie)\n * - All the amazing contributors\n * @license MIT\n */\n\nimport deepmerge from 'deepmerge';\n\nvar version = \"2.4.0\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\n/**\n * checks if passed argument is an array\n * @param  {any}  arg - the object to check\n * @return {Boolean} - true if `arg` is an array\n */\nfunction isArray(arg) {\n  return Array.isArray(arg);\n}\nfunction isUndefined(arg) {\n  return typeof arg === 'undefined';\n}\nfunction isObject(arg) {\n  return _typeof(arg) === 'object';\n}\nfunction isPureObject(arg) {\n  return _typeof(arg) === 'object' && arg !== null;\n}\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nfunction hasGlobalWindowFn() {\n  try {\n    return !isUndefined(window);\n  } catch (e) {\n    return false;\n  }\n}\nvar hasGlobalWindow = hasGlobalWindowFn();\n\nvar _global = hasGlobalWindow ? window : global;\n\nvar console = _global.console || {};\nfunction warn(str) {\n  /* istanbul ignore next */\n  if (!console || !console.warn) {\n    return;\n  }\n\n  console.warn(str);\n}\nvar showWarningNotSupported = function showWarningNotSupported() {\n  return warn('This vue app/component has no vue-meta configuration');\n};\n\n/**\n * These are constant variables used throughout the application.\n */\n// set some sane defaults\nvar defaultInfo = {\n  title: undefined,\n  titleChunk: '',\n  titleTemplate: '%s',\n  htmlAttrs: {},\n  bodyAttrs: {},\n  headAttrs: {},\n  base: [],\n  link: [],\n  meta: [],\n  style: [],\n  script: [],\n  noscript: [],\n  __dangerouslyDisableSanitizers: [],\n  __dangerouslyDisableSanitizersByTagID: {}\n};\nvar rootConfigKey = '_vueMeta'; // This is the name of the component option that contains all the information that\n// gets converted to the various meta tags & attributes for the page.\n\nvar keyName = 'metaInfo'; // This is the attribute vue-meta arguments on elements to know which it should\n// manage and which it should ignore.\n\nvar attribute = 'data-vue-meta'; // This is the attribute that goes on the `html` tag to inform `vue-meta`\n// that the server has already generated the meta tags for the initial render.\n\nvar ssrAttribute = 'data-vue-meta-server-rendered'; // This is the property that tells vue-meta to overwrite (instead of append)\n// an item in a tag list. For example, if you have two `meta` tag list items\n// that both have `vmid` of \"description\", then vue-meta will overwrite the\n// shallowest one with the deepest one.\n\nvar tagIDKeyName = 'vmid'; // This is the key name for possible meta templates\n\nvar metaTemplateKeyName = 'template'; // This is the key name for the content-holding property\n\nvar contentKeyName = 'content'; // The id used for the ssr app\n\nvar ssrAppId = 'ssr'; // How long meta update\n\nvar debounceWait = 10; // How long meta update\n\nvar waitOnDestroyed = true;\nvar defaultOptions = {\n  keyName: keyName,\n  attribute: attribute,\n  ssrAttribute: ssrAttribute,\n  tagIDKeyName: tagIDKeyName,\n  contentKeyName: contentKeyName,\n  metaTemplateKeyName: metaTemplateKeyName,\n  waitOnDestroyed: waitOnDestroyed,\n  debounceWait: debounceWait,\n  ssrAppId: ssrAppId\n}; // might be a bit ugly, but minimizes the browser bundles a bit\n\nvar defaultInfoKeys = Object.keys(defaultInfo); // The metaInfo property keys which are used to disable escaping\n\nvar disableOptionKeys = [defaultInfoKeys[12], defaultInfoKeys[13]]; // List of metaInfo property keys which are configuration options (and dont generate html)\n\nvar metaInfoOptionKeys = [defaultInfoKeys[1], defaultInfoKeys[2], 'changed'].concat(disableOptionKeys); // List of metaInfo property keys which only generates attributes and no tags\n\nvar metaInfoAttributeKeys = [defaultInfoKeys[3], defaultInfoKeys[4], defaultInfoKeys[5]]; // HTML elements which support the onload event\n\nvar tagsSupportingOnload = ['link', 'style', 'script']; // HTML elements which dont have a head tag (shortened to our needs)\n// see: https://www.w3.org/TR/html52/document-metadata.html\n\nvar tagsWithoutEndTag = ['base', 'meta', 'link']; // HTML elements which can have inner content (shortened to our needs)\n\nvar tagsWithInnerContent = ['noscript', 'script', 'style']; // Attributes which are inserted as childNodes instead of HTMLAttribute\n\nvar tagAttributeAsInnerContent = ['innerHTML', 'cssText', 'json'];\nvar tagProperties = ['once', 'skip', 'template']; // Attributes which should be added with data- prefix\n\nvar commonDataAttributes = ['body', 'pbody']; // from: https://github.com/kangax/html-minifier/blob/gh-pages/src/htmlminifier.js#L202\n\nvar booleanHtmlAttributes = ['allowfullscreen', 'amp', 'amp-boilerplate', 'async', 'autofocus', 'autoplay', 'checked', 'compact', 'controls', 'declare', 'default', 'defaultchecked', 'defaultmuted', 'defaultselected', 'defer', 'disabled', 'enabled', 'formnovalidate', 'hidden', 'indeterminate', 'inert', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nohref', 'noresize', 'noshade', 'novalidate', 'nowrap', 'open', 'pauseonexit', 'readonly', 'required', 'reversed', 'scoped', 'seamless', 'selected', 'sortable', 'truespeed', 'typemustmatch', 'visible'];\n\nvar batchId = null;\nfunction triggerUpdate(_ref, rootVm, hookName) {\n  var debounceWait = _ref.debounceWait;\n\n  // if an update was triggered during initialization or when an update was triggered by the\n  // metaInfo watcher, set initialized to null\n  // then we keep falsy value but know we need to run a triggerUpdate after initialization\n  if (!rootVm[rootConfigKey].initialized && (rootVm[rootConfigKey].initializing || hookName === 'watcher')) {\n    rootVm[rootConfigKey].initialized = null;\n  }\n\n  if (rootVm[rootConfigKey].initialized && !rootVm[rootConfigKey].pausing) {\n    // batch potential DOM updates to prevent extraneous re-rendering\n    // eslint-disable-next-line no-void\n    batchUpdate(function () {\n      return void rootVm.$meta().refresh();\n    }, debounceWait);\n  }\n}\n/**\n * Performs a batched update.\n *\n * @param  {(null|Number)} id - the ID of this update\n * @param  {Function} callback - the update to perform\n * @return {Number} id - a new ID\n */\n\nfunction batchUpdate(callback, timeout) {\n  timeout = timeout === undefined ? 10 : timeout;\n\n  if (!timeout) {\n    callback();\n    return;\n  }\n\n  clearTimeout(batchId);\n  batchId = setTimeout(function () {\n    callback();\n  }, timeout);\n  return batchId;\n}\n\n/*\n * To reduce build size, this file provides simple polyfills without\n * overly excessive type checking and without modifying\n * the global Array.prototype\n * The polyfills are automatically removed in the commonjs build\n * Also, only files in client/ & shared/ should use these functions\n * files in server/ still use normal js function\n */\nfunction find(array, predicate, thisArg) {\n  if ( !Array.prototype.find) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return array[idx];\n      }\n    }\n\n    return;\n  }\n\n  return array.find(predicate, thisArg);\n}\nfunction findIndex(array, predicate, thisArg) {\n  if ( !Array.prototype.findIndex) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return idx;\n      }\n    }\n\n    return -1;\n  }\n\n  return array.findIndex(predicate, thisArg);\n}\nfunction toArray(arg) {\n  if ( !Array.from) {\n    return Array.prototype.slice.call(arg);\n  }\n\n  return Array.from(arg);\n}\nfunction includes(array, value) {\n  if ( !Array.prototype.includes) {\n    for (var idx in array) {\n      if (array[idx] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return array.includes(value);\n}\n\nvar querySelector = function querySelector(arg, el) {\n  return (el || document).querySelectorAll(arg);\n};\nfunction getTag(tags, tag) {\n  if (!tags[tag]) {\n    tags[tag] = document.getElementsByTagName(tag)[0];\n  }\n\n  return tags[tag];\n}\nfunction getElementsKey(_ref) {\n  var body = _ref.body,\n      pbody = _ref.pbody;\n  return body ? 'body' : pbody ? 'pbody' : 'head';\n}\nfunction queryElements(parentNode, _ref2, attributes) {\n  var appId = _ref2.appId,\n      attribute = _ref2.attribute,\n      type = _ref2.type,\n      tagIDKeyName = _ref2.tagIDKeyName;\n  attributes = attributes || {};\n  var queries = [\"\".concat(type, \"[\").concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"), \"\".concat(type, \"[data-\").concat(tagIDKeyName, \"]\")].map(function (query) {\n    for (var key in attributes) {\n      var val = attributes[key];\n      var attributeValue = val && val !== true ? \"=\\\"\".concat(val, \"\\\"\") : '';\n      query += \"[data-\".concat(key).concat(attributeValue, \"]\");\n    }\n\n    return query;\n  });\n  return toArray(querySelector(queries.join(', '), parentNode));\n}\nfunction removeElementsByAppId(_ref3, appId) {\n  var attribute = _ref3.attribute;\n  toArray(querySelector(\"[\".concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"))).map(function (el) {\n    return el.remove();\n  });\n}\nfunction removeAttribute(el, attributeName) {\n  el.removeAttribute(attributeName);\n}\n\nfunction hasMetaInfo(vm) {\n  vm = vm || this;\n  return vm && (vm[rootConfigKey] === true || isObject(vm[rootConfigKey]));\n} // a component is in a metaInfo branch when itself has meta info or one of its (grand-)children has\n\nfunction inMetaInfoBranch(vm) {\n  vm = vm || this;\n  return vm && !isUndefined(vm[rootConfigKey]);\n}\n\nfunction pause(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = true;\n  return function () {\n    return resume(rootVm, refresh);\n  };\n}\nfunction resume(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = false;\n\n  if (refresh || refresh === undefined) {\n    return rootVm.$meta().refresh();\n  }\n}\n\nfunction addNavGuards(rootVm) {\n  var router = rootVm.$router; // return when nav guards already added or no router exists\n\n  if (rootVm[rootConfigKey].navGuards || !router) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  rootVm[rootConfigKey].navGuards = true;\n  router.beforeEach(function (to, from, next) {\n    pause(rootVm);\n    next();\n  });\n  router.afterEach(function () {\n    rootVm.$nextTick(function () {\n      var _resume = resume(rootVm),\n          metaInfo = _resume.metaInfo;\n\n      if (metaInfo && isFunction(metaInfo.afterNavigation)) {\n        metaInfo.afterNavigation(metaInfo);\n      }\n    });\n  });\n}\n\nvar appId = 1;\nfunction createMixin(Vue, options) {\n  // for which Vue lifecycle hooks should the metaInfo be refreshed\n  var updateOnLifecycleHook = ['activated', 'deactivated', 'beforeMount'];\n  var wasServerRendered = false; // watch for client side component updates\n\n  return {\n    beforeCreate: function beforeCreate() {\n      var _this2 = this;\n\n      var rootKey = '$root';\n      var $root = this[rootKey];\n      var $options = this.$options;\n      var devtoolsEnabled = Vue.config.devtools;\n      Object.defineProperty(this, '_hasMetaInfo', {\n        configurable: true,\n        get: function get() {\n          // Show deprecation warning once when devtools enabled\n          if (devtoolsEnabled && !$root[rootConfigKey].deprecationWarningShown) {\n            warn('VueMeta DeprecationWarning: _hasMetaInfo has been deprecated and will be removed in a future version. Please use hasMetaInfo(vm) instead');\n            $root[rootConfigKey].deprecationWarningShown = true;\n          }\n\n          return hasMetaInfo(this);\n        }\n      });\n\n      if (this === $root) {\n        $root.$once('hook:beforeMount', function () {\n          wasServerRendered = this.$el && this.$el.nodeType === 1 && this.$el.hasAttribute('data-server-rendered'); // In most cases when you have a SSR app it will be the first app thats gonna be\n          // initiated, if we cant detect the data-server-rendered attribute from Vue but we\n          // do see our own ssrAttribute then _assume_ the Vue app with appId 1 is the ssr app\n          // attempted fix for #404 & #562, but we rly need to refactor how we pass appIds from\n          // ssr to the client\n\n          if (!wasServerRendered && $root[rootConfigKey] && $root[rootConfigKey].appId === 1) {\n            var htmlTag = getTag({}, 'html');\n            wasServerRendered = htmlTag && htmlTag.hasAttribute(options.ssrAttribute);\n          }\n        });\n      } // Add a marker to know if it uses metaInfo\n      // _vnode is used to know that it's attached to a real component\n      // useful if we use some mixin to add some meta tags (like nuxt-i18n)\n\n\n      if (isUndefined($options[options.keyName]) || $options[options.keyName] === null) {\n        return;\n      }\n\n      if (!$root[rootConfigKey]) {\n        $root[rootConfigKey] = {\n          appId: appId\n        };\n        appId++;\n\n        if (devtoolsEnabled && $root.$options[options.keyName]) {\n          // use nextTick so the children should be added to $root\n          this.$nextTick(function () {\n            // find the first child that lists fnOptions\n            var child = find($root.$children, function (c) {\n              return c.$vnode && c.$vnode.fnOptions;\n            });\n\n            if (child && child.$vnode.fnOptions[options.keyName]) {\n              warn(\"VueMeta has detected a possible global mixin which adds a \".concat(options.keyName, \" property to all Vue components on the page. This could cause severe performance issues. If possible, use $meta().addApp to add meta information instead\"));\n            }\n          });\n        }\n      } // to speed up updates we keep track of branches which have a component with vue-meta info defined\n      // if _vueMeta = true it has info, if _vueMeta = false a child has info\n\n\n      if (!this[rootConfigKey]) {\n        this[rootConfigKey] = true;\n        var parent = this.$parent;\n\n        while (parent && parent !== $root) {\n          if (isUndefined(parent[rootConfigKey])) {\n            parent[rootConfigKey] = false;\n          }\n\n          parent = parent.$parent;\n        }\n      } // coerce function-style metaInfo to a computed prop so we can observe\n      // it on creation\n\n\n      if (isFunction($options[options.keyName])) {\n        $options.computed = $options.computed || {};\n        $options.computed.$metaInfo = $options[options.keyName];\n\n        if (!this.$isServer) {\n          // if computed $metaInfo exists, watch it for updates & trigger a refresh\n          // when it changes (i.e. automatically handle async actions that affect metaInfo)\n          // credit for this suggestion goes to [Sébastien Chopin](https://github.com/Atinux)\n          this.$on('hook:created', function () {\n            this.$watch('$metaInfo', function () {\n              triggerUpdate(options, this[rootKey], 'watcher');\n            });\n          });\n        }\n      } // force an initial refresh on page load and prevent other lifecycleHooks\n      // to triggerUpdate until this initial refresh is finished\n      // this is to make sure that when a page is opened in an inactive tab which\n      // has throttled rAF/timers we still immediately set the page title\n\n\n      if (isUndefined($root[rootConfigKey].initialized)) {\n        $root[rootConfigKey].initialized = this.$isServer;\n\n        if (!$root[rootConfigKey].initialized) {\n          if (!$root[rootConfigKey].initializedSsr) {\n            $root[rootConfigKey].initializedSsr = true;\n            this.$on('hook:beforeMount', function () {\n              var $root = this[rootKey]; // if this Vue-app was server rendered, set the appId to 'ssr'\n              // only one SSR app per page is supported\n\n              if (wasServerRendered) {\n                $root[rootConfigKey].appId = options.ssrAppId;\n              }\n            });\n          } // we use the mounted hook here as on page load\n\n\n          this.$on('hook:mounted', function () {\n            var $root = this[rootKey];\n\n            if ($root[rootConfigKey].initialized) {\n              return;\n            } // used in triggerUpdate to check if a change was triggered\n            // during initialization\n\n\n            $root[rootConfigKey].initializing = true; // refresh meta in nextTick so all child components have loaded\n\n            this.$nextTick(function () {\n              var _$root$$meta$refresh = $root.$meta().refresh(),\n                  tags = _$root$$meta$refresh.tags,\n                  metaInfo = _$root$$meta$refresh.metaInfo; // After ssr hydration (identifier by tags === false) check\n              // if initialized was set to null in triggerUpdate. That'd mean\n              // that during initilazation changes where triggered which need\n              // to be applied OR a metaInfo watcher was triggered before the\n              // current hook was called\n              // (during initialization all changes are blocked)\n\n\n              if (tags === false && $root[rootConfigKey].initialized === null) {\n                this.$nextTick(function () {\n                  return triggerUpdate(options, $root, 'init');\n                });\n              }\n\n              $root[rootConfigKey].initialized = true;\n              delete $root[rootConfigKey].initializing; // add the navigation guards if they havent been added yet\n              // they are needed for the afterNavigation callback\n\n              if (!options.refreshOnceOnNavigation && metaInfo.afterNavigation) {\n                addNavGuards($root);\n              }\n            });\n          }); // add the navigation guards if requested\n\n          if (options.refreshOnceOnNavigation) {\n            addNavGuards($root);\n          }\n        }\n      }\n\n      this.$on('hook:destroyed', function () {\n        var _this = this;\n\n        // do not trigger refresh:\n        // - when user configured to not wait for transitions on destroyed\n        // - when the component doesnt have a parent\n        // - doesnt have metaInfo defined\n        if (!this.$parent || !hasMetaInfo(this)) {\n          return;\n        }\n\n        delete this._hasMetaInfo;\n        this.$nextTick(function () {\n          if (!options.waitOnDestroyed || !_this.$el || !_this.$el.offsetParent) {\n            triggerUpdate(options, _this.$root, 'destroyed');\n            return;\n          } // Wait that element is hidden before refreshing meta tags (to support animations)\n\n\n          var interval = setInterval(function () {\n            if (_this.$el && _this.$el.offsetParent !== null) {\n              /* istanbul ignore next line */\n              return;\n            }\n\n            clearInterval(interval);\n            triggerUpdate(options, _this.$root, 'destroyed');\n          }, 50);\n        });\n      }); // do not trigger refresh on the server side\n\n      if (this.$isServer) {\n        /* istanbul ignore next */\n        return;\n      } // no need to add this hooks on server side\n\n\n      updateOnLifecycleHook.forEach(function (lifecycleHook) {\n        _this2.$on(\"hook:\".concat(lifecycleHook), function () {\n          triggerUpdate(options, this[rootKey], lifecycleHook);\n        });\n      });\n    }\n  };\n}\n\nfunction setOptions(options) {\n  // combine options\n  options = isObject(options) ? options : {}; // The options are set like this so they can\n  // be minified by terser while keeping the\n  // user api intact\n  // terser --mangle-properties keep_quoted=strict\n\n  /* eslint-disable dot-notation */\n\n  return {\n    keyName: options['keyName'] || defaultOptions.keyName,\n    attribute: options['attribute'] || defaultOptions.attribute,\n    ssrAttribute: options['ssrAttribute'] || defaultOptions.ssrAttribute,\n    tagIDKeyName: options['tagIDKeyName'] || defaultOptions.tagIDKeyName,\n    contentKeyName: options['contentKeyName'] || defaultOptions.contentKeyName,\n    metaTemplateKeyName: options['metaTemplateKeyName'] || defaultOptions.metaTemplateKeyName,\n    debounceWait: isUndefined(options['debounceWait']) ? defaultOptions.debounceWait : options['debounceWait'],\n    waitOnDestroyed: isUndefined(options['waitOnDestroyed']) ? defaultOptions.waitOnDestroyed : options['waitOnDestroyed'],\n    ssrAppId: options['ssrAppId'] || defaultOptions.ssrAppId,\n    refreshOnceOnNavigation: !!options['refreshOnceOnNavigation']\n  };\n  /* eslint-enable dot-notation */\n}\nfunction getOptions(options) {\n  var optionsCopy = {};\n\n  for (var key in options) {\n    optionsCopy[key] = options[key];\n  }\n\n  return optionsCopy;\n}\n\nfunction ensureIsArray(arg, key) {\n  if (!key || !isObject(arg)) {\n    return isArray(arg) ? arg : [];\n  }\n\n  if (!isArray(arg[key])) {\n    arg[key] = [];\n  }\n\n  return arg;\n}\n\nvar serverSequences = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/\"/g, '&quot;'], [/'/g, '&#x27;']];\nvar clientSequences = [[/&/g, \"&\"], [/</g, \"<\"], [/>/g, \">\"], [/\"/g, \"\\\"\"], [/'/g, \"'\"]]; // sanitizes potentially dangerous characters\n\nfunction escape(info, options, escapeOptions, escapeKeys) {\n  var tagIDKeyName = options.tagIDKeyName;\n  var _escapeOptions$doEsca = escapeOptions.doEscape,\n      doEscape = _escapeOptions$doEsca === void 0 ? function (v) {\n    return v;\n  } : _escapeOptions$doEsca;\n  var escaped = {};\n\n  for (var key in info) {\n    var value = info[key]; // no need to escape configuration options\n\n    if (includes(metaInfoOptionKeys, key)) {\n      escaped[key] = value;\n      continue;\n    } // do not use destructuring for disableOptionKeys, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n\n\n    var disableKey = disableOptionKeys[0];\n\n    if (escapeOptions[disableKey] && includes(escapeOptions[disableKey], key)) {\n      // this info[key] doesnt need to escaped if the option is listed in __dangerouslyDisableSanitizers\n      escaped[key] = value;\n      continue;\n    }\n\n    var tagId = info[tagIDKeyName];\n\n    if (tagId) {\n      disableKey = disableOptionKeys[1]; // keys which are listed in __dangerouslyDisableSanitizersByTagID for the current vmid do not need to be escaped\n\n      if (escapeOptions[disableKey] && escapeOptions[disableKey][tagId] && includes(escapeOptions[disableKey][tagId], key)) {\n        escaped[key] = value;\n        continue;\n      }\n    }\n\n    if (isString(value)) {\n      escaped[key] = doEscape(value);\n    } else if (isArray(value)) {\n      escaped[key] = value.map(function (v) {\n        if (isPureObject(v)) {\n          return escape(v, options, escapeOptions, true);\n        }\n\n        return doEscape(v);\n      });\n    } else if (isPureObject(value)) {\n      escaped[key] = escape(value, options, escapeOptions, true);\n    } else {\n      escaped[key] = value;\n    }\n\n    if (escapeKeys) {\n      var escapedKey = doEscape(key);\n\n      if (key !== escapedKey) {\n        escaped[escapedKey] = escaped[key];\n        delete escaped[key];\n      }\n    }\n  }\n\n  return escaped;\n}\nfunction escapeMetaInfo(options, info, escapeSequences) {\n  escapeSequences = escapeSequences || []; // do not use destructuring for seq, it increases transpiled size\n  // due to var checks while we are guaranteed the structure of the cb\n\n  var escapeOptions = {\n    doEscape: function doEscape(value) {\n      return escapeSequences.reduce(function (val, seq) {\n        return val.replace(seq[0], seq[1]);\n      }, value);\n    }\n  };\n  disableOptionKeys.forEach(function (disableKey, index) {\n    if (index === 0) {\n      ensureIsArray(info, disableKey);\n    } else if (index === 1) {\n      for (var key in info[disableKey]) {\n        ensureIsArray(info[disableKey], key);\n      }\n    }\n\n    escapeOptions[disableKey] = info[disableKey];\n  }); // begin sanitization\n\n  return escape(info, options, escapeOptions);\n}\n\nfunction applyTemplate(_ref, headObject, template, chunk) {\n  var component = _ref.component,\n      metaTemplateKeyName = _ref.metaTemplateKeyName,\n      contentKeyName = _ref.contentKeyName;\n\n  if (template === true || headObject[metaTemplateKeyName] === true) {\n    // abort, template was already applied\n    return false;\n  }\n\n  if (isUndefined(template) && headObject[metaTemplateKeyName]) {\n    template = headObject[metaTemplateKeyName];\n    headObject[metaTemplateKeyName] = true;\n  } // return early if no template defined\n\n\n  if (!template) {\n    // cleanup faulty template properties\n    delete headObject[metaTemplateKeyName];\n    return false;\n  }\n\n  if (isUndefined(chunk)) {\n    chunk = headObject[contentKeyName];\n  }\n\n  headObject[contentKeyName] = isFunction(template) ? template.call(component, chunk) : template.replace(/%s/g, chunk);\n  return true;\n}\n\nfunction _arrayMerge(_ref, target, source) {\n  var component = _ref.component,\n      tagIDKeyName = _ref.tagIDKeyName,\n      metaTemplateKeyName = _ref.metaTemplateKeyName,\n      contentKeyName = _ref.contentKeyName;\n  // we concat the arrays without merging objects contained in,\n  // but we check for a `vmid` property on each object in the array\n  // using an O(1) lookup associative array exploit\n  var destination = [];\n\n  if (!target.length && !source.length) {\n    return destination;\n  }\n\n  target.forEach(function (targetItem, targetIndex) {\n    // no tagID so no need to check for duplicity\n    if (!targetItem[tagIDKeyName]) {\n      destination.push(targetItem);\n      return;\n    }\n\n    var sourceIndex = findIndex(source, function (item) {\n      return item[tagIDKeyName] === targetItem[tagIDKeyName];\n    });\n    var sourceItem = source[sourceIndex]; // source doesnt contain any duplicate vmid's, we can keep targetItem\n\n    if (sourceIndex === -1) {\n      destination.push(targetItem);\n      return;\n    } // when sourceItem explictly defines contentKeyName or innerHTML as undefined, its\n    // an indication that we need to skip the default behaviour or child has preference over parent\n    // which means we keep the targetItem and ignore/remove the sourceItem\n\n\n    if (contentKeyName in sourceItem && sourceItem[contentKeyName] === undefined || 'innerHTML' in sourceItem && sourceItem.innerHTML === undefined) {\n      destination.push(targetItem); // remove current index from source array so its not concatenated to destination below\n\n      source.splice(sourceIndex, 1);\n      return;\n    } // we now know that targetItem is a duplicate and we should ignore it in favor of sourceItem\n    // if source specifies null as content then ignore both the target as the source\n\n\n    if (sourceItem[contentKeyName] === null || sourceItem.innerHTML === null) {\n      // remove current index from source array so its not concatenated to destination below\n      source.splice(sourceIndex, 1);\n      return;\n    } // now we only need to check if the target has a template to combine it with the source\n\n\n    var targetTemplate = targetItem[metaTemplateKeyName];\n\n    if (!targetTemplate) {\n      return;\n    }\n\n    var sourceTemplate = sourceItem[metaTemplateKeyName];\n\n    if (!sourceTemplate) {\n      // use parent template and child content\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, targetTemplate); // set template to true to indicate template was already applied\n\n      sourceItem.template = true;\n      return;\n    }\n\n    if (!sourceItem[contentKeyName]) {\n      // use parent content and child template\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, undefined, targetItem[contentKeyName]);\n    }\n  });\n  return destination.concat(source);\n}\nvar warningShown = false;\nfunction merge(target, source, options) {\n  options = options || {}; // remove properties explicitly set to false so child components can\n  // optionally _not_ overwrite the parents content\n  // (for array properties this is checked in arrayMerge)\n\n  if (source.title === undefined) {\n    delete source.title;\n  }\n\n  metaInfoAttributeKeys.forEach(function (attrKey) {\n    if (!source[attrKey]) {\n      return;\n    }\n\n    for (var key in source[attrKey]) {\n      if (key in source[attrKey] && source[attrKey][key] === undefined) {\n        if (includes(booleanHtmlAttributes, key) && !warningShown) {\n          warn('VueMeta: Please note that since v2 the value undefined is not used to indicate boolean attributes anymore, see migration guide for details');\n          warningShown = true;\n        }\n\n        delete source[attrKey][key];\n      }\n    }\n  });\n  return deepmerge(target, source, {\n    arrayMerge: function arrayMerge(t, s) {\n      return _arrayMerge(options, t, s);\n    }\n  });\n}\n\nfunction getComponentMetaInfo(options, component) {\n  return getComponentOption(options || {}, component, defaultInfo);\n}\n/**\n * Returns the `opts.option` $option value of the given `opts.component`.\n * If methods are encountered, they will be bound to the component context.\n * If `opts.deep` is true, will recursively merge all child component\n * `opts.option` $option values into the returned result.\n *\n * @param  {Object} opts - options\n * @param  {Object} opts.component - Vue component to fetch option data from\n * @param  {Boolean} opts.deep - look for data in child components as well?\n * @param  {Function} opts.arrayMerge - how should arrays be merged?\n * @param  {String} opts.keyName - the name of the option to look for\n * @param  {Object} [result={}] - result so far\n * @return {Object} result - final aggregated result\n */\n\nfunction getComponentOption(options, component, result) {\n  result = result || {};\n\n  if (component._inactive) {\n    return result;\n  }\n\n  options = options || {};\n  var _options = options,\n      keyName = _options.keyName;\n  var $metaInfo = component.$metaInfo,\n      $options = component.$options,\n      $children = component.$children; // only collect option data if it exists\n\n  if ($options[keyName]) {\n    // if $metaInfo exists then [keyName] was defined as a function\n    // and set to the computed prop $metaInfo in the mixin\n    // using the computed prop should be a small performance increase\n    // because Vue caches those internally\n    var data = $metaInfo || $options[keyName]; // only merge data with result when its an object\n    // eg it could be a function when metaInfo() returns undefined\n    // dueo to the or statement above\n\n    if (isObject(data)) {\n      result = merge(result, data, options);\n    }\n  } // collect & aggregate child options if deep = true\n\n\n  if ($children.length) {\n    $children.forEach(function (childComponent) {\n      // check if the childComponent is in a branch\n      // return otherwise so we dont walk all component branches unnecessarily\n      if (!inMetaInfoBranch(childComponent)) {\n        return;\n      }\n\n      result = getComponentOption(options, childComponent, result);\n    });\n  }\n\n  return result;\n}\n\nvar callbacks = [];\nfunction isDOMComplete(d) {\n  return (d || document).readyState === 'complete';\n}\nfunction addCallback(query, callback) {\n  if (arguments.length === 1) {\n    callback = query;\n    query = '';\n  }\n\n  callbacks.push([query, callback]);\n}\nfunction addCallbacks(_ref, type, tags, autoAddListeners) {\n  var tagIDKeyName = _ref.tagIDKeyName;\n  var hasAsyncCallback = false;\n  tags.forEach(function (tag) {\n    if (!tag[tagIDKeyName] || !tag.callback) {\n      return;\n    }\n\n    hasAsyncCallback = true;\n    addCallback(\"\".concat(type, \"[data-\").concat(tagIDKeyName, \"=\\\"\").concat(tag[tagIDKeyName], \"\\\"]\"), tag.callback);\n  });\n\n  if (!autoAddListeners || !hasAsyncCallback) {\n    return hasAsyncCallback;\n  }\n\n  return addListeners();\n}\nfunction addListeners() {\n  if (isDOMComplete()) {\n    applyCallbacks();\n    return;\n  } // Instead of using a MutationObserver, we just apply\n\n  /* istanbul ignore next */\n\n\n  document.onreadystatechange = function () {\n    applyCallbacks();\n  };\n}\nfunction applyCallbacks(matchElement) {\n  callbacks.forEach(function (args) {\n    // do not use destructuring for args, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n    var query = args[0];\n    var callback = args[1];\n    var selector = \"\".concat(query, \"[onload=\\\"this.__vm_l=1\\\"]\");\n    var elements = [];\n\n    if (!matchElement) {\n      elements = toArray(querySelector(selector));\n    }\n\n    if (matchElement && matchElement.matches(selector)) {\n      elements = [matchElement];\n    }\n\n    elements.forEach(function (element) {\n      /* __vm_cb: whether the load callback has been called\n       * __vm_l: set by onload attribute, whether the element was loaded\n       * __vm_ev: whether the event listener was added or not\n       */\n      if (element.__vm_cb) {\n        return;\n      }\n\n      var onload = function onload() {\n        /* Mark that the callback for this element has already been called,\n         * this prevents the callback to run twice in some (rare) conditions\n         */\n        element.__vm_cb = true;\n        /* onload needs to be removed because we only need the\n         * attribute after ssr and if we dont remove it the node\n         * will fail isEqualNode on the client\n         */\n\n        removeAttribute(element, 'onload');\n        callback(element);\n      };\n      /* IE9 doesnt seem to load scripts synchronously,\n       * causing a script sometimes/often already to be loaded\n       * when we add the event listener below (thus adding an onload event\n       * listener has no use because it will never be triggered).\n       * Therefore we add the onload attribute during ssr, and\n       * check here if it was already loaded or not\n       */\n\n\n      if (element.__vm_l) {\n        onload();\n        return;\n      }\n\n      if (!element.__vm_ev) {\n        element.__vm_ev = true;\n        element.addEventListener('load', onload);\n      }\n    });\n  });\n}\n\n// instead of adding it to the html\n\nvar attributeMap = {};\n/**\n * Updates the document's html tag attributes\n *\n * @param  {Object} attrs - the new document html attributes\n * @param  {HTMLElement} tag - the HTMLElement tag to update with new attrs\n */\n\nfunction updateAttribute(appId, options, type, attrs, tag) {\n  var _ref = options || {},\n      attribute = _ref.attribute;\n\n  var vueMetaAttrString = tag.getAttribute(attribute);\n\n  if (vueMetaAttrString) {\n    attributeMap[type] = JSON.parse(decodeURI(vueMetaAttrString));\n    removeAttribute(tag, attribute);\n  }\n\n  var data = attributeMap[type] || {};\n  var toUpdate = []; // remove attributes from the map\n  // which have been removed for this appId\n\n  for (var attr in data) {\n    if (data[attr] !== undefined && appId in data[attr]) {\n      toUpdate.push(attr);\n\n      if (!attrs[attr]) {\n        delete data[attr][appId];\n      }\n    }\n  }\n\n  for (var _attr in attrs) {\n    var attrData = data[_attr];\n\n    if (!attrData || attrData[appId] !== attrs[_attr]) {\n      toUpdate.push(_attr);\n\n      if (attrs[_attr] !== undefined) {\n        data[_attr] = data[_attr] || {};\n        data[_attr][appId] = attrs[_attr];\n      }\n    }\n  }\n\n  for (var _i = 0, _toUpdate = toUpdate; _i < _toUpdate.length; _i++) {\n    var _attr2 = _toUpdate[_i];\n    var _attrData = data[_attr2];\n    var attrValues = [];\n\n    for (var _appId in _attrData) {\n      Array.prototype.push.apply(attrValues, [].concat(_attrData[_appId]));\n    }\n\n    if (attrValues.length) {\n      var attrValue = includes(booleanHtmlAttributes, _attr2) && attrValues.some(Boolean) ? '' : attrValues.filter(function (v) {\n        return v !== undefined;\n      }).join(' ');\n      tag.setAttribute(_attr2, attrValue);\n    } else {\n      removeAttribute(tag, _attr2);\n    }\n  }\n\n  attributeMap[type] = data;\n}\n\n/**\n * Updates the document title\n *\n * @param  {String} title - the new title of the document\n */\nfunction updateTitle(title) {\n  if (!title && title !== '') {\n    return;\n  }\n\n  document.title = title;\n}\n\n/**\n * Updates meta tags inside <head> and <body> on the client. Borrowed from `react-helmet`:\n * https://github.com/nfl/react-helmet/blob/004d448f8de5f823d10f838b02317521180f34da/src/Helmet.js#L195-L245\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} type - the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - a representation of what tags changed\n */\n\nfunction updateTag(appId, options, type, tags, head, body) {\n  var _ref = options || {},\n      attribute = _ref.attribute,\n      tagIDKeyName = _ref.tagIDKeyName;\n\n  var dataAttributes = commonDataAttributes.slice();\n  dataAttributes.push(tagIDKeyName);\n  var newElements = [];\n  var queryOptions = {\n    appId: appId,\n    attribute: attribute,\n    type: type,\n    tagIDKeyName: tagIDKeyName\n  };\n  var currentElements = {\n    head: queryElements(head, queryOptions),\n    pbody: queryElements(body, queryOptions, {\n      pbody: true\n    }),\n    body: queryElements(body, queryOptions, {\n      body: true\n    })\n  };\n\n  if (tags.length > 1) {\n    // remove duplicates that could have been found by merging tags\n    // which include a mixin with metaInfo and that mixin is used\n    // by multiple components on the same page\n    var found = [];\n    tags = tags.filter(function (x) {\n      var k = JSON.stringify(x);\n      var res = !includes(found, k);\n      found.push(k);\n      return res;\n    });\n  }\n\n  tags.forEach(function (tag) {\n    if (tag.skip) {\n      return;\n    }\n\n    var newElement = document.createElement(type);\n\n    if (!tag.once) {\n      newElement.setAttribute(attribute, appId);\n    }\n\n    Object.keys(tag).forEach(function (attr) {\n      /* istanbul ignore next */\n      if (includes(tagProperties, attr)) {\n        return;\n      }\n\n      if (attr === 'innerHTML') {\n        newElement.innerHTML = tag.innerHTML;\n        return;\n      }\n\n      if (attr === 'json') {\n        newElement.innerHTML = JSON.stringify(tag.json);\n        return;\n      }\n\n      if (attr === 'cssText') {\n        if (newElement.styleSheet) {\n          /* istanbul ignore next */\n          newElement.styleSheet.cssText = tag.cssText;\n        } else {\n          newElement.appendChild(document.createTextNode(tag.cssText));\n        }\n\n        return;\n      }\n\n      if (attr === 'callback') {\n        newElement.onload = function () {\n          return tag[attr](newElement);\n        };\n\n        return;\n      }\n\n      var _attr = includes(dataAttributes, attr) ? \"data-\".concat(attr) : attr;\n\n      var isBooleanAttribute = includes(booleanHtmlAttributes, attr);\n\n      if (isBooleanAttribute && !tag[attr]) {\n        return;\n      }\n\n      var value = isBooleanAttribute ? '' : tag[attr];\n      newElement.setAttribute(_attr, value);\n    });\n    var oldElements = currentElements[getElementsKey(tag)]; // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.\n\n    var indexToDelete;\n    var hasEqualElement = oldElements.some(function (existingTag, index) {\n      indexToDelete = index;\n      return newElement.isEqualNode(existingTag);\n    });\n\n    if (hasEqualElement && (indexToDelete || indexToDelete === 0)) {\n      oldElements.splice(indexToDelete, 1);\n    } else {\n      newElements.push(newElement);\n    }\n  });\n  var oldElements = [];\n\n  for (var _type in currentElements) {\n    Array.prototype.push.apply(oldElements, currentElements[_type]);\n  } // remove old elements\n\n\n  oldElements.forEach(function (element) {\n    element.parentNode.removeChild(element);\n  }); // insert new elements\n\n  newElements.forEach(function (element) {\n    if (element.hasAttribute('data-body')) {\n      body.appendChild(element);\n      return;\n    }\n\n    if (element.hasAttribute('data-pbody')) {\n      body.insertBefore(element, body.firstChild);\n      return;\n    }\n\n    head.appendChild(element);\n  });\n  return {\n    oldTags: oldElements,\n    newTags: newElements\n  };\n}\n\n/**\n * Performs client-side updates when new meta info is received\n *\n * @param  {Object} newInfo - the meta info to update to\n */\n\nfunction updateClientMetaInfo(appId, options, newInfo) {\n  options = options || {};\n  var _options = options,\n      ssrAttribute = _options.ssrAttribute,\n      ssrAppId = _options.ssrAppId; // only cache tags for current update\n\n  var tags = {};\n  var htmlTag = getTag(tags, 'html'); // if this is a server render, then dont update\n\n  if (appId === ssrAppId && htmlTag.hasAttribute(ssrAttribute)) {\n    // remove the server render attribute so we can update on (next) changes\n    removeAttribute(htmlTag, ssrAttribute); // add load callbacks if the\n\n    var addLoadListeners = false;\n    tagsSupportingOnload.forEach(function (type) {\n      if (newInfo[type] && addCallbacks(options, type, newInfo[type])) {\n        addLoadListeners = true;\n      }\n    });\n\n    if (addLoadListeners) {\n      addListeners();\n    }\n\n    return false;\n  } // initialize tracked changes\n\n\n  var tagsAdded = {};\n  var tagsRemoved = {};\n\n  for (var type in newInfo) {\n    // ignore these\n    if (includes(metaInfoOptionKeys, type)) {\n      continue;\n    }\n\n    if (type === 'title') {\n      // update the title\n      updateTitle(newInfo.title);\n      continue;\n    }\n\n    if (includes(metaInfoAttributeKeys, type)) {\n      var tagName = type.substr(0, 4);\n      updateAttribute(appId, options, type, newInfo[type], getTag(tags, tagName));\n      continue;\n    } // tags should always be an array, ignore if it isnt\n\n\n    if (!isArray(newInfo[type])) {\n      continue;\n    }\n\n    var _updateTag = updateTag(appId, options, type, newInfo[type], getTag(tags, 'head'), getTag(tags, 'body')),\n        oldTags = _updateTag.oldTags,\n        newTags = _updateTag.newTags;\n\n    if (newTags.length) {\n      tagsAdded[type] = newTags;\n      tagsRemoved[type] = oldTags;\n    }\n  }\n\n  return {\n    tagsAdded: tagsAdded,\n    tagsRemoved: tagsRemoved\n  };\n}\n\nvar appsMetaInfo;\nfunction addApp(rootVm, appId, options) {\n  return {\n    set: function set(metaInfo) {\n      return setMetaInfo(rootVm, appId, options, metaInfo);\n    },\n    remove: function remove() {\n      return removeMetaInfo(rootVm, appId, options);\n    }\n  };\n}\nfunction setMetaInfo(rootVm, appId, options, metaInfo) {\n  // if a vm exists _and_ its mounted then immediately update\n  if (rootVm && rootVm.$el) {\n    return updateClientMetaInfo(appId, options, metaInfo);\n  } // store for later, the info\n  // will be set on the first refresh\n\n\n  appsMetaInfo = appsMetaInfo || {};\n  appsMetaInfo[appId] = metaInfo;\n}\nfunction removeMetaInfo(rootVm, appId, options) {\n  if (rootVm && rootVm.$el) {\n    var tags = {};\n\n    var _iterator = _createForOfIteratorHelper(metaInfoAttributeKeys),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n        var tagName = type.substr(0, 4);\n        updateAttribute(appId, options, type, {}, getTag(tags, tagName));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return removeElementsByAppId(options, appId);\n  }\n\n  if (appsMetaInfo[appId]) {\n    delete appsMetaInfo[appId];\n    clearAppsMetaInfo();\n  }\n}\nfunction getAppsMetaInfo() {\n  return appsMetaInfo;\n}\nfunction clearAppsMetaInfo(force) {\n  if (force || !Object.keys(appsMetaInfo).length) {\n    appsMetaInfo = undefined;\n  }\n}\n\n/**\n * Returns the correct meta info for the given component\n * (child components will overwrite parent meta info)\n *\n * @param  {Object} component - the Vue instance to get meta info from\n * @return {Object} - returned meta info\n */\n\nfunction getMetaInfo(options, info, escapeSequences, component) {\n  options = options || {};\n  escapeSequences = escapeSequences || [];\n  var _options = options,\n      tagIDKeyName = _options.tagIDKeyName; // Remove all \"template\" tags from meta\n  // backup the title chunk in case user wants access to it\n\n  if (info.title) {\n    info.titleChunk = info.title;\n  } // replace title with populated template\n\n\n  if (info.titleTemplate && info.titleTemplate !== '%s') {\n    applyTemplate({\n      component: component,\n      contentKeyName: 'title'\n    }, info, info.titleTemplate, info.titleChunk || '');\n  } // convert base tag to an array so it can be handled the same way\n  // as the other tags\n\n\n  if (info.base) {\n    info.base = Object.keys(info.base).length ? [info.base] : [];\n  }\n\n  if (info.meta) {\n    // remove meta items with duplicate vmid's\n    info.meta = info.meta.filter(function (metaItem, index, arr) {\n      var hasVmid = !!metaItem[tagIDKeyName];\n\n      if (!hasVmid) {\n        return true;\n      }\n\n      var isFirstItemForVmid = index === findIndex(arr, function (item) {\n        return item[tagIDKeyName] === metaItem[tagIDKeyName];\n      });\n      return isFirstItemForVmid;\n    }); // apply templates if needed\n\n    info.meta.forEach(function (metaObject) {\n      return applyTemplate(options, metaObject);\n    });\n  }\n\n  return escapeMetaInfo(options, info, escapeSequences);\n}\n\n/**\n * When called, will update the current meta info with new meta info.\n * Useful when updating meta info as the result of an asynchronous\n * action that resolves after the initial render takes place.\n *\n * Credit to [Sébastien Chopin](https://github.com/Atinux) for the suggestion\n * to implement this method.\n *\n * @return {Object} - new meta info\n */\n\nfunction refresh(rootVm, options) {\n  options = options || {}; // make sure vue-meta was initiated\n\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, clientSequences, rootVm);\n  var appId = rootVm[rootConfigKey].appId;\n  var tags = updateClientMetaInfo(appId, options, metaInfo); // emit \"event\" with new info\n\n  if (tags && isFunction(metaInfo.changed)) {\n    metaInfo.changed(metaInfo, tags.tagsAdded, tags.tagsRemoved);\n    tags = {\n      addedTags: tags.tagsAdded,\n      removedTags: tags.tagsRemoved\n    };\n  }\n\n  var appsMetaInfo = getAppsMetaInfo();\n\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      updateClientMetaInfo(additionalAppId, options, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n\n    clearAppsMetaInfo(true);\n  }\n\n  return {\n    vm: rootVm,\n    metaInfo: metaInfo,\n    // eslint-disable-line object-shorthand\n    tags: tags\n  };\n}\n\n/**\n * Generates tag attributes for use on the server.\n *\n * @param  {('bodyAttrs'|'htmlAttrs'|'headAttrs')} type - the type of attributes to generate\n * @param  {Object} data - the attributes to generate\n * @return {Object} - the attribute generator\n */\n\nfunction attributeGenerator(options, type, data, _ref) {\n  var addSsrAttribute = _ref.addSsrAttribute;\n\n  var _ref2 = options || {},\n      attribute = _ref2.attribute,\n      ssrAttribute = _ref2.ssrAttribute;\n\n  var attributeStr = '';\n\n  for (var attr in data) {\n    var attrData = data[attr];\n    var attrValues = [];\n\n    for (var appId in attrData) {\n      attrValues.push.apply(attrValues, _toConsumableArray([].concat(attrData[appId])));\n    }\n\n    if (attrValues.length) {\n      attributeStr += booleanHtmlAttributes.includes(attr) && attrValues.some(Boolean) ? \"\".concat(attr) : \"\".concat(attr, \"=\\\"\").concat(attrValues.join(' '), \"\\\"\");\n      attributeStr += ' ';\n    }\n  }\n\n  if (attributeStr) {\n    attributeStr += \"\".concat(attribute, \"=\\\"\").concat(encodeURI(JSON.stringify(data)), \"\\\"\");\n  }\n\n  if (type === 'htmlAttrs' && addSsrAttribute) {\n    return \"\".concat(ssrAttribute).concat(attributeStr ? ' ' : '').concat(attributeStr);\n  }\n\n  return attributeStr;\n}\n\n/**\n * Generates title output for the server\n *\n * @param  {'title'} type - the string \"title\"\n * @param  {String} data - the title text\n * @return {Object} - the title generator\n */\nfunction titleGenerator(options, type, data, generatorOptions) {\n  var _ref = generatorOptions || {},\n      ln = _ref.ln;\n\n  if (!data) {\n    return '';\n  }\n\n  return \"<\".concat(type, \">\").concat(data, \"</\").concat(type, \">\").concat(ln ? '\\n' : '');\n}\n\n/**\n * Generates meta, base, link, style, script, noscript tags for use on the server\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - the tag generator\n */\n\nfunction tagGenerator(options, type, tags, generatorOptions) {\n  var _ref = options || {},\n      ssrAppId = _ref.ssrAppId,\n      attribute = _ref.attribute,\n      tagIDKeyName = _ref.tagIDKeyName;\n\n  var _ref2 = generatorOptions || {},\n      appId = _ref2.appId,\n      _ref2$isSSR = _ref2.isSSR,\n      isSSR = _ref2$isSSR === void 0 ? true : _ref2$isSSR,\n      _ref2$body = _ref2.body,\n      body = _ref2$body === void 0 ? false : _ref2$body,\n      _ref2$pbody = _ref2.pbody,\n      pbody = _ref2$pbody === void 0 ? false : _ref2$pbody,\n      _ref2$ln = _ref2.ln,\n      ln = _ref2$ln === void 0 ? false : _ref2$ln;\n\n  var dataAttributes = [tagIDKeyName].concat(_toConsumableArray(commonDataAttributes));\n\n  if (!tags || !tags.length) {\n    return '';\n  } // build a string containing all tags of this type\n\n\n  return tags.reduce(function (tagsStr, tag) {\n    if (tag.skip) {\n      return tagsStr;\n    }\n\n    var tagKeys = Object.keys(tag);\n\n    if (tagKeys.length === 0) {\n      return tagsStr; // Bail on empty tag object\n    }\n\n    if (Boolean(tag.body) !== body || Boolean(tag.pbody) !== pbody) {\n      return tagsStr;\n    }\n\n    var attrs = tag.once ? '' : \" \".concat(attribute, \"=\\\"\").concat(appId || (isSSR === false ? '1' : ssrAppId), \"\\\"\"); // build a string containing all attributes of this tag\n\n    for (var attr in tag) {\n      // these attributes are treated as children on the tag\n      if (tagAttributeAsInnerContent.includes(attr) || tagProperties.includes(attr)) {\n        continue;\n      }\n\n      if (attr === 'callback') {\n        attrs += ' onload=\"this.__vm_l=1\"';\n        continue;\n      } // these form the attribute list for this tag\n\n\n      var prefix = '';\n\n      if (dataAttributes.includes(attr)) {\n        prefix = 'data-';\n      }\n\n      var isBooleanAttr = !prefix && booleanHtmlAttributes.includes(attr);\n\n      if (isBooleanAttr && !tag[attr]) {\n        continue;\n      }\n\n      attrs += \" \".concat(prefix).concat(attr) + (isBooleanAttr ? '' : \"=\\\"\".concat(tag[attr], \"\\\"\"));\n    }\n\n    var json = '';\n\n    if (tag.json) {\n      json = JSON.stringify(tag.json);\n    } // grab child content from one of these attributes, if possible\n\n\n    var content = tag.innerHTML || tag.cssText || json; // generate tag exactly without any other redundant attribute\n    // these tags have no end tag\n\n    var hasEndTag = !tagsWithoutEndTag.includes(type); // these tag types will have content inserted\n\n    var hasContent = hasEndTag && tagsWithInnerContent.includes(type); // the final string for this specific tag\n\n    return \"\".concat(tagsStr, \"<\").concat(type).concat(attrs).concat(!hasContent && hasEndTag ? '/' : '', \">\") + (hasContent ? \"\".concat(content, \"</\").concat(type, \">\") : '') + (ln ? '\\n' : '');\n  }, '');\n}\n\n/**\n * Converts a meta info property to one that can be stringified on the server\n *\n * @param  {String} type - the type of data to convert\n * @param  {(String|Object|Array<Object>)} data - the data value\n * @return {Object} - the new injector\n */\n\nfunction generateServerInjector(options, metaInfo, globalInjectOptions) {\n  var serverInjector = {\n    data: metaInfo,\n    extraData: undefined,\n    addInfo: function addInfo(appId, metaInfo) {\n      this.extraData = this.extraData || {};\n      this.extraData[appId] = metaInfo;\n    },\n    callInjectors: function callInjectors(opts) {\n      var m = this.injectors; // only call title for the head\n\n      return (opts.body || opts.pbody ? '' : m.title.text(opts)) + m.meta.text(opts) + m.base.text(opts) + m.link.text(opts) + m.style.text(opts) + m.script.text(opts) + m.noscript.text(opts);\n    },\n    injectors: {\n      head: function head(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln\n        }));\n      },\n      bodyPrepend: function bodyPrepend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          pbody: true\n        }));\n      },\n      bodyAppend: function bodyAppend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          body: true\n        }));\n      }\n    }\n  };\n\n  var _loop = function _loop(type) {\n    if (metaInfoOptionKeys.includes(type)) {\n      return \"continue\";\n    }\n\n    serverInjector.injectors[type] = {\n      text: function text(injectOptions) {\n        var addSsrAttribute = injectOptions === true;\n        injectOptions = _objectSpread2(_objectSpread2({\n          addSsrAttribute: addSsrAttribute\n        }, globalInjectOptions), injectOptions);\n\n        if (type === 'title') {\n          return titleGenerator(options, type, serverInjector.data[type], injectOptions);\n        }\n\n        if (metaInfoAttributeKeys.includes(type)) {\n          var attributeData = {};\n          var data = serverInjector.data[type];\n\n          if (data) {\n            var appId = injectOptions.isSSR === false ? '1' : options.ssrAppId;\n\n            for (var attr in data) {\n              attributeData[attr] = _defineProperty({}, appId, data[attr]);\n            }\n          }\n\n          if (serverInjector.extraData) {\n            for (var _appId in serverInjector.extraData) {\n              var _data = serverInjector.extraData[_appId][type];\n\n              if (_data) {\n                for (var _attr in _data) {\n                  attributeData[_attr] = _objectSpread2(_objectSpread2({}, attributeData[_attr]), {}, _defineProperty({}, _appId, _data[_attr]));\n                }\n              }\n            }\n          }\n\n          return attributeGenerator(options, type, attributeData, injectOptions);\n        }\n\n        var str = tagGenerator(options, type, serverInjector.data[type], injectOptions);\n\n        if (serverInjector.extraData) {\n          for (var _appId2 in serverInjector.extraData) {\n            var _data2 = serverInjector.extraData[_appId2][type];\n            var extraStr = tagGenerator(options, type, _data2, _objectSpread2({\n              appId: _appId2\n            }, injectOptions));\n            str = \"\".concat(str).concat(extraStr);\n          }\n        }\n\n        return str;\n      }\n    };\n  };\n\n  for (var type in defaultInfo) {\n    var _ret = _loop(type);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return serverInjector;\n}\n\n/**\n * Converts the state of the meta info object such that each item\n * can be compiled to a tag string on the server\n *\n * @vm {Object} - Vue instance - ideally the root component\n * @return {Object} - server meta info with `toString` methods\n */\n\nfunction inject(rootVm, options, injectOptions) {\n  // make sure vue-meta was initiated\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences, rootVm); // generate server injector\n\n  var serverInjector = generateServerInjector(options, metaInfo, injectOptions); // add meta info from additional apps\n\n  var appsMetaInfo = getAppsMetaInfo();\n\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      serverInjector.addInfo(additionalAppId, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n\n    clearAppsMetaInfo(true);\n  }\n\n  return serverInjector.injectors;\n}\n\nfunction $meta(options) {\n  options = options || {};\n  /**\n   * Returns an injector for server-side rendering.\n   * @this {Object} - the Vue instance (a root component)\n   * @return {Object} - injector\n   */\n\n  var $root = this.$root;\n  return {\n    getOptions: function getOptions$1() {\n      return getOptions(options);\n    },\n    setOptions: function setOptions(newOptions) {\n      var refreshNavKey = 'refreshOnceOnNavigation';\n\n      if (newOptions && newOptions[refreshNavKey]) {\n        options.refreshOnceOnNavigation = !!newOptions[refreshNavKey];\n        addNavGuards($root);\n      }\n\n      var debounceWaitKey = 'debounceWait';\n\n      if (newOptions && debounceWaitKey in newOptions) {\n        var debounceWait = parseInt(newOptions[debounceWaitKey]);\n\n        if (!isNaN(debounceWait)) {\n          options.debounceWait = debounceWait;\n        }\n      }\n\n      var waitOnDestroyedKey = 'waitOnDestroyed';\n\n      if (newOptions && waitOnDestroyedKey in newOptions) {\n        options.waitOnDestroyed = !!newOptions[waitOnDestroyedKey];\n      }\n    },\n    refresh: function refresh$1() {\n      return refresh($root, options);\n    },\n    inject: function inject$1(injectOptions) {\n      return  inject($root, options, injectOptions) ;\n    },\n    pause: function pause$1() {\n      return pause($root);\n    },\n    resume: function resume$1() {\n      return resume($root);\n    },\n    addApp: function addApp$1(appId) {\n      return addApp($root, appId, options);\n    }\n  };\n}\n\nfunction generate(rawInfo, options) {\n  options = setOptions(options);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences);\n  var serverInjector = generateServerInjector(options, metaInfo);\n  return serverInjector.injectors;\n}\n\n/**\n * Plugin install function.\n * @param {Function} Vue - the Vue constructor.\n */\n\nfunction install(Vue, options) {\n  if (Vue.__vuemeta_installed) {\n    return;\n  }\n\n  Vue.__vuemeta_installed = true;\n  options = setOptions(options);\n\n  Vue.prototype.$meta = function () {\n    return $meta.call(this, options);\n  };\n\n  Vue.mixin(createMixin(Vue, options));\n}\n\nvar index = {\n  version: version,\n  install: install,\n  generate: function generate$1(metaInfo, options) {\n    return  generate(metaInfo, options) ;\n  },\n  hasMetaInfo: hasMetaInfo\n};\n\nexport default index;\n"]},"metadata":{},"sourceType":"module"}