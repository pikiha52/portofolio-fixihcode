{"ast":null,"code":"\"use strict\"; // Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs = require(\"fs\");\n\nconst gcpMetadata = require(\"gcp-metadata\");\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst transporters_1 = require(\"../transporters\");\n\nconst computeclient_1 = require(\"./computeclient\");\n\nconst idtokenclient_1 = require(\"./idtokenclient\");\n\nconst envDetect_1 = require(\"./envDetect\");\n\nconst jwtclient_1 = require(\"./jwtclient\");\n\nconst refreshclient_1 = require(\"./refreshclient\");\n\nconst impersonated_1 = require(\"./impersonated\");\n\nconst externalclient_1 = require(\"./externalclient\");\n\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst externalAccountAuthorizedUserClient_1 = require(\"./externalAccountAuthorizedUserClient\");\n\nconst util_1 = require(\"../util\");\n\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\nconst GoogleAuthExceptionMessages = {\n  NO_PROJECT_ID_FOUND: 'Unable to detect a Project Id in the current environment. \\n' + 'To learn more about authentication and Google APIs, visit: \\n' + 'https://cloud.google.com/docs/authentication/getting-started',\n  NO_CREDENTIALS_FOUND: 'Unable to find credentials in current environment. \\n' + 'To learn more about authentication and Google APIs, visit: \\n' + 'https://cloud.google.com/docs/authentication/getting-started',\n  NO_UNIVERSE_DOMAIN_FOUND: 'Unable to detect a Universe Domain in the current environment.\\n' + 'To learn more about Universe Domain retrieval, visit: \\n' + 'https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys'\n};\n\nclass GoogleAuth {\n  // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n  /**\n   * Configuration is resolved in the following order of precedence:\n   * - {@link GoogleAuthOptions.credentials `credentials`}\n   * - {@link GoogleAuthOptions.keyFilename `keyFilename`}\n   * - {@link GoogleAuthOptions.keyFile `keyFile`}\n   *\n   * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the\n   * {@link AuthClient `AuthClient`s}.\n   *\n   * @param opts\n   */\n\n\n  constructor(opts) {\n    /**\n     * Caches a value indicating whether the auth layer is running on Google\n     * Compute Engine.\n     * @private\n     */\n    this.checkIsGCE = undefined; // To save the contents of the JSON credential file\n\n    this.jsonContent = null;\n    this.cachedCredential = null;\n    this.clientOptions = {};\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.cachedCredential = opts.authClient || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n    this.clientOptions = opts.clientOptions || {};\n\n    if (opts.universeDomain) {\n      this.clientOptions.universeDomain = opts.universeDomain;\n    }\n  } // GAPIC client libraries should always use self-signed JWTs. The following\n  // variables are set on the JWT client in order to indicate the type of library,\n  // and sign the JWT with the correct audience and scopes (if not supplied).\n\n\n  setGapicJWTValues(client) {\n    client.defaultServicePath = this.defaultServicePath;\n    client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n    client.defaultScopes = this.defaultScopes;\n  }\n\n  getProjectId(callback) {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n  /**\n   * A temporary method for internal `getProjectId` usages where `null` is\n   * acceptable. In a future major release, `getProjectId` should return `null`\n   * (as the `Promise<string | null>` base signature describes) and this private\n   * method should be removed.\n   *\n   * @returns Promise that resolves with project id (or `null`)\n   */\n\n\n  async getProjectIdOptional() {\n    try {\n      return await this.getProjectId();\n    } catch (e) {\n      if (e instanceof Error && e.message === GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n        return null;\n      } else {\n        throw e;\n      }\n    }\n  }\n  /*\n   * A private method for finding and caching a projectId.\n   *\n   * Supports environments in order of precedence:\n   * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n   * - GOOGLE_APPLICATION_CREDENTIALS JSON file\n   * - Cloud SDK: `gcloud config config-helper --format json`\n   * - GCE project ID from metadata server\n   *\n   * @returns projectId\n   */\n\n\n  async findAndCacheProjectId() {\n    let projectId = null;\n    projectId || (projectId = await this.getProductionProjectId());\n    projectId || (projectId = await this.getFileProjectId());\n    projectId || (projectId = await this.getDefaultServiceProjectId());\n    projectId || (projectId = await this.getGCEProjectId());\n    projectId || (projectId = await this.getExternalAccountClientProjectId());\n\n    if (projectId) {\n      this._cachedProjectId = projectId;\n      return projectId;\n    } else {\n      throw new Error(GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n    }\n  }\n\n  async getProjectIdAsync() {\n    if (this._cachedProjectId) {\n      return this._cachedProjectId;\n    }\n\n    if (!this._findProjectIdPromise) {\n      this._findProjectIdPromise = this.findAndCacheProjectId();\n    }\n\n    return this._findProjectIdPromise;\n  }\n  /**\n   * Retrieves a universe domain from the metadata server via\n   * {@link gcpMetadata.universe}.\n   *\n   * @returns a universe domain\n   */\n\n\n  async getUniverseDomainFromMetadataServer() {\n    var _a;\n\n    let universeDomain;\n\n    try {\n      universeDomain = await gcpMetadata.universe('universe_domain');\n      universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);\n    } catch (e) {\n      if (e && ((_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {\n        universeDomain = authclient_1.DEFAULT_UNIVERSE;\n      } else {\n        throw e;\n      }\n    }\n\n    return universeDomain;\n  }\n  /**\n   * Retrieves, caches, and returns the universe domain in the following order\n   * of precedence:\n   * - The universe domain in {@link GoogleAuth.clientOptions}\n   * - An existing or ADC {@link AuthClient}'s universe domain\n   * - {@link gcpMetadata.universe}, if {@link Compute} client\n   *\n   * @returns The universe domain\n   */\n\n\n  async getUniverseDomain() {\n    let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get('universe_domain');\n\n    try {\n      universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = (await this.getClient()).universeDomain;\n    } catch (_a) {\n      // client or ADC is not available\n      universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = authclient_1.DEFAULT_UNIVERSE;\n    }\n\n    return universeDomain;\n  }\n  /**\n   * @returns Any scopes (user-specified or default scopes specified by the\n   *   client library) that need to be set on the current Auth client.\n   */\n\n\n  getAnyScopes() {\n    return this.scopes || this.defaultScopes;\n  }\n\n  getApplicationDefault(optionsOrCallback = {}, callback) {\n    let options;\n\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  async getApplicationDefaultAsync(options = {}) {\n    // If we've already got a cached credential, return it.\n    // This will also preserve one's configured quota project, in case they\n    // set one directly on the credential previously.\n    if (this.cachedCredential) {\n      return await this.prepareAndCacheADC(this.cachedCredential);\n    } // Since this is a 'new' ADC to cache we will use the environment variable\n    // if it's available. We prefer this value over the value from ADC.\n\n\n    const quotaProjectIdOverride = process.env['GOOGLE_CLOUD_QUOTA_PROJECT'];\n    let credential; // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local\n    // developer scenarios.\n\n    credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n\n    if (credential) {\n      if (credential instanceof jwtclient_1.JWT) {\n        credential.scopes = this.scopes;\n      } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n        credential.scopes = this.getAnyScopes();\n      }\n\n      return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n    } // Look in the well-known credential file location.\n\n\n    credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n\n    if (credential) {\n      if (credential instanceof jwtclient_1.JWT) {\n        credential.scopes = this.scopes;\n      } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n        credential.scopes = this.getAnyScopes();\n      }\n\n      return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n    } // Determine if we're running on GCE.\n\n\n    if (await this._checkIsGCE()) {\n      // set universe domain for Compute client\n      if (!(0, util_1.originalOrCamelOptions)(options).get('universe_domain')) {\n        options.universeDomain = await this.getUniverseDomainFromMetadataServer();\n      }\n\n      options.scopes = this.getAnyScopes();\n      return await this.prepareAndCacheADC(new computeclient_1.Compute(options), quotaProjectIdOverride);\n    }\n\n    throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n  }\n\n  async prepareAndCacheADC(credential, quotaProjectIdOverride) {\n    const projectId = await this.getProjectIdOptional();\n\n    if (quotaProjectIdOverride) {\n      credential.quotaProjectId = quotaProjectIdOverride;\n    }\n\n    this.cachedCredential = credential;\n    return {\n      credential,\n      projectId\n    };\n  }\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * Checks for GCP Residency, then fallback to checking if metadata server\n   * is available.\n   *\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n\n\n  async _checkIsGCE() {\n    if (this.checkIsGCE === undefined) {\n      this.checkIsGCE = gcpMetadata.getGCPResidency() || (await gcpMetadata.isAvailable());\n    }\n\n    return this.checkIsGCE;\n  }\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n\n\n  async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n    const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] || process.env['google_application_credentials'];\n\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return null;\n    }\n\n    try {\n      return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n    } catch (e) {\n      if (e instanceof Error) {\n        e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n\n\n  async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n    // First, figure out the location of the file, depending upon the OS type.\n    let location = null;\n\n    if (this._isWindows()) {\n      // Windows\n      location = process.env['APPDATA'];\n    } else {\n      // Linux or Mac\n      const home = process.env['HOME'];\n\n      if (home) {\n        location = path.join(home, '.config');\n      }\n    } // If we found the root path, expand it.\n\n\n    if (location) {\n      location = path.join(location, 'gcloud', 'application_default_credentials.json');\n\n      if (!fs.existsSync(location)) {\n        location = null;\n      }\n    } // The file does not exist.\n\n\n    if (!location) {\n      return null;\n    } // The file seems to exist. Try to use it.\n\n\n    const client = await this._getApplicationCredentialsFromFilePath(location, options);\n    return client;\n  }\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n\n\n  async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      throw new Error('The file path is invalid.');\n    } // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n\n\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = fs.realpathSync(filePath);\n\n      if (!fs.lstatSync(filePath).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n      }\n\n      throw err;\n    } // Now open a read stream on the file, and parse it.\n\n\n    const readStream = fs.createReadStream(filePath);\n    return this.fromStream(readStream, options);\n  }\n  /**\n   * Create a credentials instance using a given impersonated input options.\n   * @param json The impersonated input object.\n   * @returns JWT or UserRefresh Client with data\n   */\n\n\n  fromImpersonatedJSON(json) {\n    var _a, _b, _c, _d, _e;\n\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing an  impersonated refresh token');\n    }\n\n    if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n      throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n    }\n\n    if (!json.source_credentials) {\n      throw new Error('The incoming JSON object does not contain a source_credentials field');\n    }\n\n    if (!json.service_account_impersonation_url) {\n      throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');\n    } // Create source client for impersonation\n\n\n    const sourceClient = new refreshclient_1.UserRefreshClient();\n    sourceClient.fromJSON(json.source_credentials);\n\n    if (((_a = json.service_account_impersonation_url) === null || _a === void 0 ? void 0 : _a.length) > 256) {\n      /**\n       * Prevents DOS attacks.\n       * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/85}\n       **/\n      throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);\n    } // Extreact service account from service_account_impersonation_url\n\n\n    const targetPrincipal = (_c = (_b = /(?<target>[^/]+):generateAccessToken$/.exec(json.service_account_impersonation_url)) === null || _b === void 0 ? void 0 : _b.groups) === null || _c === void 0 ? void 0 : _c.target;\n\n    if (!targetPrincipal) {\n      throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n    }\n\n    const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== void 0 ? _d : [];\n    const client = new impersonated_1.Impersonated({ ...json,\n      delegates: (_e = json.delegates) !== null && _e !== void 0 ? _e : [],\n      sourceClient: sourceClient,\n      targetPrincipal: targetPrincipal,\n      targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes]\n    });\n    return client;\n  }\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @param options The JWT or UserRefresh options for the client\n   * @returns JWT or UserRefresh Client with data\n   */\n\n\n  fromJSON(json, options = {}) {\n    let client; // user's preferred universe domain\n\n    const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get('universe_domain');\n\n    if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n      client = new refreshclient_1.UserRefreshClient(options);\n      client.fromJSON(json);\n    } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n      client = this.fromImpersonatedJSON(json);\n    } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n      client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n      client.scopes = this.getAnyScopes();\n    } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n      client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n    } else {\n      options.scopes = this.scopes;\n      client = new jwtclient_1.JWT(options);\n      this.setGapicJWTValues(client);\n      client.fromJSON(json);\n    }\n\n    if (preferredUniverseDomain) {\n      client.universeDomain = preferredUniverseDomain;\n    }\n\n    return client;\n  }\n  /**\n   * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n   * object used to instantiate and the client.\n   * @param json The input object.\n   * @param options The JWT or UserRefresh options for the client\n   * @returns JWT or UserRefresh Client with data\n   */\n\n\n  _cacheClientFromJSON(json, options) {\n    const client = this.fromJSON(json, options); // cache both raw data used to instantiate client and client itself.\n\n    this.jsonContent = json;\n    this.cachedCredential = client;\n    return client;\n  }\n\n  fromStream(inputStream, optionsOrCallback = {}, callback) {\n    let options = {};\n\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n\n    if (callback) {\n      this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  fromStreamAsync(inputStream, options) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error('Must pass in a stream containing the Google auth settings.');\n      }\n\n      let s = '';\n      inputStream.setEncoding('utf8').on('error', reject).on('data', chunk => s += chunk).on('end', () => {\n        try {\n          try {\n            const data = JSON.parse(s);\n\n            const r = this._cacheClientFromJSON(data, options);\n\n            return resolve(r);\n          } catch (err) {\n            // If we failed parsing this.keyFileName, assume that it\n            // is a PEM or p12 certificate:\n            if (!this.keyFilename) throw err;\n            const client = new jwtclient_1.JWT({ ...this.clientOptions,\n              keyFile: this.keyFilename\n            });\n            this.cachedCredential = client;\n            this.setGapicJWTValues(client);\n            return resolve(client);\n          }\n        } catch (err) {\n          return reject(err);\n        }\n      });\n    });\n  }\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n\n\n  fromAPIKey(apiKey, options) {\n    options = options || {};\n    const client = new jwtclient_1.JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n\n\n  _isWindows() {\n    const sys = os.platform();\n\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n\n\n  async getDefaultServiceProjectId() {\n    return new Promise(resolve => {\n      (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) => {\n        if (!err && stdout) {\n          try {\n            const projectId = JSON.parse(stdout).configuration.properties.core.project;\n            resolve(projectId);\n            return;\n          } catch (e) {// ignore errors\n          }\n        }\n\n        resolve(null);\n      });\n    });\n  }\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n\n\n  getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'] || process.env['gcloud_project'] || process.env['google_cloud_project'];\n  }\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n\n\n  async getFileProjectId() {\n    if (this.cachedCredential) {\n      // Try to read the project ID from the cached credentials file\n      return this.cachedCredential.projectId;\n    } // Ensure the projectId is loaded from the keyFile if available.\n\n\n    if (this.keyFilename) {\n      const creds = await this.getClient();\n\n      if (creds && creds.projectId) {\n        return creds.projectId;\n      }\n    } // Try to load a credentials file and read its project ID\n\n\n    const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n\n    if (r) {\n      return r.projectId;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Gets the project ID from external account client if available.\n   */\n\n\n  async getExternalAccountClientProjectId() {\n    if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n      return null;\n    }\n\n    const creds = await this.getClient(); // Do not suppress the underlying error, as the error could contain helpful\n    // information for debugging and fixing. This is especially true for\n    // external account creds as in order to get the project ID, the following\n    // operations have to succeed:\n    // 1. Valid credentials file should be supplied.\n    // 2. Ability to retrieve access tokens from STS token exchange API.\n    // 3. Ability to exchange for service account impersonated credentials (if\n    //    enabled).\n    // 4. Ability to get project info using the access token from step 2 or 3.\n    // Without surfacing the error, it is harder for developers to determine\n    // which step went wrong.\n\n    return await creds.getProjectId();\n  }\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n\n\n  async getGCEProjectId() {\n    try {\n      const r = await gcpMetadata.project('project-id');\n      return r;\n    } catch (e) {\n      // Ignore any errors\n      return null;\n    }\n  }\n\n  getCredentials(callback) {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  async getCredentialsAsync() {\n    const client = await this.getClient();\n\n    if (client instanceof impersonated_1.Impersonated) {\n      return {\n        client_email: client.getTargetPrincipal()\n      };\n    }\n\n    if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n      const serviceAccountEmail = client.getServiceAccountEmail();\n\n      if (serviceAccountEmail) {\n        return {\n          client_email: serviceAccountEmail,\n          universe_domain: client.universeDomain\n        };\n      }\n    }\n\n    if (this.jsonContent) {\n      return {\n        client_email: this.jsonContent.client_email,\n        private_key: this.jsonContent.private_key,\n        universe_domain: this.jsonContent.universe_domain\n      };\n    }\n\n    if (await this._checkIsGCE()) {\n      const [client_email, universe_domain] = await Promise.all([gcpMetadata.instance('service-accounts/default/email'), this.getUniverseDomain()]);\n      return {\n        client_email,\n        universe_domain\n      };\n    }\n\n    throw new Error(GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);\n  }\n  /**\n   * Automatically obtain an {@link AuthClient `AuthClient`} based on the\n   * provided configuration. If no options were passed, use Application\n   * Default Credentials.\n   */\n\n\n  async getClient() {\n    if (!this.cachedCredential) {\n      if (this.jsonContent) {\n        this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n      } else if (this.keyFilename) {\n        const filePath = path.resolve(this.keyFilename);\n        const stream = fs.createReadStream(filePath);\n        await this.fromStreamAsync(stream, this.clientOptions);\n      } else {\n        await this.getApplicationDefaultAsync(this.clientOptions);\n      }\n    }\n\n    return this.cachedCredential;\n  }\n  /**\n   * Creates a client which will fetch an ID token for authorization.\n   * @param targetAudience the audience for the fetched ID token.\n   * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n   */\n\n\n  async getIdTokenClient(targetAudience) {\n    const client = await this.getClient();\n\n    if (!('fetchIdToken' in client)) {\n      throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n    }\n\n    return new idtokenclient_1.IdTokenClient({\n      targetAudience,\n      idTokenProvider: client\n    });\n  }\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n\n\n  async getAccessToken() {\n    const client = await this.getClient();\n    return (await client.getAccessToken()).token;\n  }\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n\n\n  async getRequestHeaders(url) {\n    const client = await this.getClient();\n    return client.getRequestHeaders(url);\n  }\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n\n\n  async authorizeRequest(opts) {\n    opts = opts || {};\n    const url = opts.url || opts.uri;\n    const client = await this.getClient();\n    const headers = await client.getRequestHeaders(url);\n    opts.headers = Object.assign(opts.headers || {}, headers);\n    return opts;\n  }\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  async request(opts) {\n    const client = await this.getClient();\n    return client.request(opts);\n  }\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n\n\n  getEnv() {\n    return (0, envDetect_1.getEnv)();\n  }\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   * @param endpoint A custom endpoint to use.\n   *\n   * @example\n   * ```\n   * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');\n   * ```\n   */\n\n\n  async sign(data, endpoint) {\n    const client = await this.getClient();\n    const universe = await this.getUniverseDomain();\n    endpoint = endpoint || `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;\n\n    if (client instanceof impersonated_1.Impersonated) {\n      const signed = await client.sign(data);\n      return signed.signedBlob;\n    }\n\n    const crypto = (0, crypto_1.createCrypto)();\n\n    if (client instanceof jwtclient_1.JWT && client.key) {\n      const sign = await crypto.sign(client.key, data);\n      return sign;\n    }\n\n    const creds = await this.getCredentials();\n\n    if (!creds.client_email) {\n      throw new Error('Cannot sign data without `client_email`.');\n    }\n\n    return this.signBlob(crypto, creds.client_email, data, endpoint);\n  }\n\n  async signBlob(crypto, emailOrUniqueId, data, endpoint) {\n    const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);\n    const res = await this.request({\n      method: 'POST',\n      url: url.href,\n      data: {\n        payload: crypto.encodeBase64StringUtf8(data)\n      },\n      retry: true,\n      retryConfig: {\n        httpMethodsToRetry: ['POST']\n      }\n    });\n    return res.data.signedBlob;\n  }\n\n}\n\nexports.GoogleAuth = GoogleAuth;\n/**\n * Export DefaultTransporter as a static property of the class.\n */\n\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;","map":{"version":3,"sources":["/Users/fikihalan/Documents/source/frontend/portofolio-fixihcode/node_modules/google-auth-library/build/src/auth/googleauth.js"],"names":["Object","defineProperty","exports","value","GoogleAuth","CLOUD_SDK_CLIENT_ID","child_process_1","require","fs","gcpMetadata","os","path","crypto_1","transporters_1","computeclient_1","idtokenclient_1","envDetect_1","jwtclient_1","refreshclient_1","impersonated_1","externalclient_1","baseexternalclient_1","authclient_1","externalAccountAuthorizedUserClient_1","util_1","GoogleAuthExceptionMessages","NO_PROJECT_ID_FOUND","NO_CREDENTIALS_FOUND","NO_UNIVERSE_DOMAIN_FOUND","isGCE","checkIsGCE","constructor","opts","undefined","jsonContent","cachedCredential","clientOptions","_cachedProjectId","projectId","authClient","keyFilename","keyFile","scopes","credentials","universeDomain","setGapicJWTValues","client","defaultServicePath","useJWTAccessWithScope","defaultScopes","getProjectId","callback","getProjectIdAsync","then","r","getProjectIdOptional","e","Error","message","findAndCacheProjectId","getProductionProjectId","getFileProjectId","getDefaultServiceProjectId","getGCEProjectId","getExternalAccountClientProjectId","_findProjectIdPromise","getUniverseDomainFromMetadataServer","_a","universe","DEFAULT_UNIVERSE","response","status","getUniverseDomain","originalOrCamelOptions","get","getClient","getAnyScopes","getApplicationDefault","optionsOrCallback","options","getApplicationDefaultAsync","credential","prepareAndCacheADC","quotaProjectIdOverride","process","env","_tryGetApplicationCredentialsFromEnvironmentVariable","JWT","BaseExternalAccountClient","_tryGetApplicationCredentialsFromWellKnownFile","_checkIsGCE","Compute","quotaProjectId","getGCPResidency","isAvailable","credentialsPath","length","_getApplicationCredentialsFromFilePath","location","_isWindows","home","join","existsSync","filePath","realpathSync","lstatSync","isFile","err","readStream","createReadStream","fromStream","fromImpersonatedJSON","json","_b","_c","_d","_e","type","IMPERSONATED_ACCOUNT_TYPE","source_credentials","service_account_impersonation_url","sourceClient","UserRefreshClient","fromJSON","RangeError","targetPrincipal","exec","groups","target","targetScopes","Impersonated","delegates","Array","isArray","preferredUniverseDomain","USER_REFRESH_ACCOUNT_TYPE","EXTERNAL_ACCOUNT_TYPE","ExternalAccountClient","EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE","ExternalAccountAuthorizedUserClient","_cacheClientFromJSON","inputStream","fromStreamAsync","Promise","resolve","reject","s","setEncoding","on","chunk","data","JSON","parse","fromAPIKey","apiKey","sys","platform","substring","toLowerCase","stdout","configuration","properties","core","project","creds","getCredentials","getCredentialsAsync","client_email","getTargetPrincipal","serviceAccountEmail","getServiceAccountEmail","universe_domain","private_key","all","instance","stream","getIdTokenClient","targetAudience","IdTokenClient","idTokenProvider","getAccessToken","token","getRequestHeaders","url","authorizeRequest","uri","headers","assign","request","getEnv","sign","endpoint","signed","signedBlob","crypto","createCrypto","key","signBlob","emailOrUniqueId","URL","res","method","href","payload","encodeBase64StringUtf8","retry","retryConfig","httpMethodsToRetry","DefaultTransporter"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = require(\"child_process\");\nconst fs = require(\"fs\");\nconst gcpMetadata = require(\"gcp-metadata\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst transporters_1 = require(\"../transporters\");\nconst computeclient_1 = require(\"./computeclient\");\nconst idtokenclient_1 = require(\"./idtokenclient\");\nconst envDetect_1 = require(\"./envDetect\");\nconst jwtclient_1 = require(\"./jwtclient\");\nconst refreshclient_1 = require(\"./refreshclient\");\nconst impersonated_1 = require(\"./impersonated\");\nconst externalclient_1 = require(\"./externalclient\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\nconst authclient_1 = require(\"./authclient\");\nconst externalAccountAuthorizedUserClient_1 = require(\"./externalAccountAuthorizedUserClient\");\nconst util_1 = require(\"../util\");\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\nconst GoogleAuthExceptionMessages = {\n    NO_PROJECT_ID_FOUND: 'Unable to detect a Project Id in the current environment. \\n' +\n        'To learn more about authentication and Google APIs, visit: \\n' +\n        'https://cloud.google.com/docs/authentication/getting-started',\n    NO_CREDENTIALS_FOUND: 'Unable to find credentials in current environment. \\n' +\n        'To learn more about authentication and Google APIs, visit: \\n' +\n        'https://cloud.google.com/docs/authentication/getting-started',\n    NO_UNIVERSE_DOMAIN_FOUND: 'Unable to detect a Universe Domain in the current environment.\\n' +\n        'To learn more about Universe Domain retrieval, visit: \\n' +\n        'https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys',\n};\nclass GoogleAuth {\n    // Note:  this properly is only public to satisify unit tests.\n    // https://github.com/Microsoft/TypeScript/issues/5228\n    get isGCE() {\n        return this.checkIsGCE;\n    }\n    /**\n     * Configuration is resolved in the following order of precedence:\n     * - {@link GoogleAuthOptions.credentials `credentials`}\n     * - {@link GoogleAuthOptions.keyFilename `keyFilename`}\n     * - {@link GoogleAuthOptions.keyFile `keyFile`}\n     *\n     * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the\n     * {@link AuthClient `AuthClient`s}.\n     *\n     * @param opts\n     */\n    constructor(opts) {\n        /**\n         * Caches a value indicating whether the auth layer is running on Google\n         * Compute Engine.\n         * @private\n         */\n        this.checkIsGCE = undefined;\n        // To save the contents of the JSON credential file\n        this.jsonContent = null;\n        this.cachedCredential = null;\n        this.clientOptions = {};\n        opts = opts || {};\n        this._cachedProjectId = opts.projectId || null;\n        this.cachedCredential = opts.authClient || null;\n        this.keyFilename = opts.keyFilename || opts.keyFile;\n        this.scopes = opts.scopes;\n        this.jsonContent = opts.credentials || null;\n        this.clientOptions = opts.clientOptions || {};\n        if (opts.universeDomain) {\n            this.clientOptions.universeDomain = opts.universeDomain;\n        }\n    }\n    // GAPIC client libraries should always use self-signed JWTs. The following\n    // variables are set on the JWT client in order to indicate the type of library,\n    // and sign the JWT with the correct audience and scopes (if not supplied).\n    setGapicJWTValues(client) {\n        client.defaultServicePath = this.defaultServicePath;\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n        client.defaultScopes = this.defaultScopes;\n    }\n    getProjectId(callback) {\n        if (callback) {\n            this.getProjectIdAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getProjectIdAsync();\n        }\n    }\n    /**\n     * A temporary method for internal `getProjectId` usages where `null` is\n     * acceptable. In a future major release, `getProjectId` should return `null`\n     * (as the `Promise<string | null>` base signature describes) and this private\n     * method should be removed.\n     *\n     * @returns Promise that resolves with project id (or `null`)\n     */\n    async getProjectIdOptional() {\n        try {\n            return await this.getProjectId();\n        }\n        catch (e) {\n            if (e instanceof Error &&\n                e.message === GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n                return null;\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    /*\n     * A private method for finding and caching a projectId.\n     *\n     * Supports environments in order of precedence:\n     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n     * - GOOGLE_APPLICATION_CREDENTIALS JSON file\n     * - Cloud SDK: `gcloud config config-helper --format json`\n     * - GCE project ID from metadata server\n     *\n     * @returns projectId\n     */\n    async findAndCacheProjectId() {\n        let projectId = null;\n        projectId || (projectId = await this.getProductionProjectId());\n        projectId || (projectId = await this.getFileProjectId());\n        projectId || (projectId = await this.getDefaultServiceProjectId());\n        projectId || (projectId = await this.getGCEProjectId());\n        projectId || (projectId = await this.getExternalAccountClientProjectId());\n        if (projectId) {\n            this._cachedProjectId = projectId;\n            return projectId;\n        }\n        else {\n            throw new Error(GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n        }\n    }\n    async getProjectIdAsync() {\n        if (this._cachedProjectId) {\n            return this._cachedProjectId;\n        }\n        if (!this._findProjectIdPromise) {\n            this._findProjectIdPromise = this.findAndCacheProjectId();\n        }\n        return this._findProjectIdPromise;\n    }\n    /**\n     * Retrieves a universe domain from the metadata server via\n     * {@link gcpMetadata.universe}.\n     *\n     * @returns a universe domain\n     */\n    async getUniverseDomainFromMetadataServer() {\n        var _a;\n        let universeDomain;\n        try {\n            universeDomain = await gcpMetadata.universe('universe_domain');\n            universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);\n        }\n        catch (e) {\n            if (e && ((_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {\n                universeDomain = authclient_1.DEFAULT_UNIVERSE;\n            }\n            else {\n                throw e;\n            }\n        }\n        return universeDomain;\n    }\n    /**\n     * Retrieves, caches, and returns the universe domain in the following order\n     * of precedence:\n     * - The universe domain in {@link GoogleAuth.clientOptions}\n     * - An existing or ADC {@link AuthClient}'s universe domain\n     * - {@link gcpMetadata.universe}, if {@link Compute} client\n     *\n     * @returns The universe domain\n     */\n    async getUniverseDomain() {\n        let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get('universe_domain');\n        try {\n            universeDomain !== null && universeDomain !== void 0 ? universeDomain : (universeDomain = (await this.getClient()).universeDomain);\n        }\n        catch (_a) {\n            // client or ADC is not available\n            universeDomain !== null && universeDomain !== void 0 ? universeDomain : (universeDomain = authclient_1.DEFAULT_UNIVERSE);\n        }\n        return universeDomain;\n    }\n    /**\n     * @returns Any scopes (user-specified or default scopes specified by the\n     *   client library) that need to be set on the current Auth client.\n     */\n    getAnyScopes() {\n        return this.scopes || this.defaultScopes;\n    }\n    getApplicationDefault(optionsOrCallback = {}, callback) {\n        let options;\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n        }\n        else {\n            return this.getApplicationDefaultAsync(options);\n        }\n    }\n    async getApplicationDefaultAsync(options = {}) {\n        // If we've already got a cached credential, return it.\n        // This will also preserve one's configured quota project, in case they\n        // set one directly on the credential previously.\n        if (this.cachedCredential) {\n            return await this.prepareAndCacheADC(this.cachedCredential);\n        }\n        // Since this is a 'new' ADC to cache we will use the environment variable\n        // if it's available. We prefer this value over the value from ADC.\n        const quotaProjectIdOverride = process.env['GOOGLE_CLOUD_QUOTA_PROJECT'];\n        let credential;\n        // Check for the existence of a local environment variable pointing to the\n        // location of the credential file. This is typically used in local\n        // developer scenarios.\n        credential =\n            await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            }\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Look in the well-known credential file location.\n        credential =\n            await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            }\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Determine if we're running on GCE.\n        if (await this._checkIsGCE()) {\n            // set universe domain for Compute client\n            if (!(0, util_1.originalOrCamelOptions)(options).get('universe_domain')) {\n                options.universeDomain =\n                    await this.getUniverseDomainFromMetadataServer();\n            }\n            options.scopes = this.getAnyScopes();\n            return await this.prepareAndCacheADC(new computeclient_1.Compute(options), quotaProjectIdOverride);\n        }\n        throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n    }\n    async prepareAndCacheADC(credential, quotaProjectIdOverride) {\n        const projectId = await this.getProjectIdOptional();\n        if (quotaProjectIdOverride) {\n            credential.quotaProjectId = quotaProjectIdOverride;\n        }\n        this.cachedCredential = credential;\n        return { credential, projectId };\n    }\n    /**\n     * Determines whether the auth layer is running on Google Compute Engine.\n     * Checks for GCP Residency, then fallback to checking if metadata server\n     * is available.\n     *\n     * @returns A promise that resolves with the boolean.\n     * @api private\n     */\n    async _checkIsGCE() {\n        if (this.checkIsGCE === undefined) {\n            this.checkIsGCE =\n                gcpMetadata.getGCPResidency() || (await gcpMetadata.isAvailable());\n        }\n        return this.checkIsGCE;\n    }\n    /**\n     * Attempts to load default credentials from the environment variable path..\n     * @returns Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n        const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||\n            process.env['google_application_credentials'];\n        if (!credentialsPath || credentialsPath.length === 0) {\n            return null;\n        }\n        try {\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Attempts to load default credentials from a well-known file location\n     * @return Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n        // First, figure out the location of the file, depending upon the OS type.\n        let location = null;\n        if (this._isWindows()) {\n            // Windows\n            location = process.env['APPDATA'];\n        }\n        else {\n            // Linux or Mac\n            const home = process.env['HOME'];\n            if (home) {\n                location = path.join(home, '.config');\n            }\n        }\n        // If we found the root path, expand it.\n        if (location) {\n            location = path.join(location, 'gcloud', 'application_default_credentials.json');\n            if (!fs.existsSync(location)) {\n                location = null;\n            }\n        }\n        // The file does not exist.\n        if (!location) {\n            return null;\n        }\n        // The file seems to exist. Try to use it.\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\n        return client;\n    }\n    /**\n     * Attempts to load default credentials from a file at the given path..\n     * @param filePath The path to the file to read.\n     * @returns Promise that resolves with the OAuth2Client\n     * @api private\n     */\n    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n        // Make sure the path looks like a string.\n        if (!filePath || filePath.length === 0) {\n            throw new Error('The file path is invalid.');\n        }\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = fs.realpathSync(filePath);\n            if (!fs.lstatSync(filePath).isFile()) {\n                throw new Error();\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        // Now open a read stream on the file, and parse it.\n        const readStream = fs.createReadStream(filePath);\n        return this.fromStream(readStream, options);\n    }\n    /**\n     * Create a credentials instance using a given impersonated input options.\n     * @param json The impersonated input object.\n     * @returns JWT or UserRefresh Client with data\n     */\n    fromImpersonatedJSON(json) {\n        var _a, _b, _c, _d, _e;\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing an  impersonated refresh token');\n        }\n        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n        }\n        if (!json.source_credentials) {\n            throw new Error('The incoming JSON object does not contain a source_credentials field');\n        }\n        if (!json.service_account_impersonation_url) {\n            throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');\n        }\n        // Create source client for impersonation\n        const sourceClient = new refreshclient_1.UserRefreshClient();\n        sourceClient.fromJSON(json.source_credentials);\n        if (((_a = json.service_account_impersonation_url) === null || _a === void 0 ? void 0 : _a.length) > 256) {\n            /**\n             * Prevents DOS attacks.\n             * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/85}\n             **/\n            throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);\n        }\n        // Extreact service account from service_account_impersonation_url\n        const targetPrincipal = (_c = (_b = /(?<target>[^/]+):generateAccessToken$/.exec(json.service_account_impersonation_url)) === null || _b === void 0 ? void 0 : _b.groups) === null || _c === void 0 ? void 0 : _c.target;\n        if (!targetPrincipal) {\n            throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n        }\n        const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== void 0 ? _d : [];\n        const client = new impersonated_1.Impersonated({\n            ...json,\n            delegates: (_e = json.delegates) !== null && _e !== void 0 ? _e : [],\n            sourceClient: sourceClient,\n            targetPrincipal: targetPrincipal,\n            targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes],\n        });\n        return client;\n    }\n    /**\n     * Create a credentials instance using the given input options.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n    fromJSON(json, options = {}) {\n        let client;\n        // user's preferred universe domain\n        const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get('universe_domain');\n        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n            client = new refreshclient_1.UserRefreshClient(options);\n            client.fromJSON(json);\n        }\n        else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            client = this.fromImpersonatedJSON(json);\n        }\n        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n            client.scopes = this.getAnyScopes();\n        }\n        else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n            client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n        }\n        else {\n            options.scopes = this.scopes;\n            client = new jwtclient_1.JWT(options);\n            this.setGapicJWTValues(client);\n            client.fromJSON(json);\n        }\n        if (preferredUniverseDomain) {\n            client.universeDomain = preferredUniverseDomain;\n        }\n        return client;\n    }\n    /**\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n     * object used to instantiate and the client.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n    _cacheClientFromJSON(json, options) {\n        const client = this.fromJSON(json, options);\n        // cache both raw data used to instantiate client and client itself.\n        this.jsonContent = json;\n        this.cachedCredential = client;\n        return client;\n    }\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream, options);\n        }\n    }\n    fromStreamAsync(inputStream, options) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                throw new Error('Must pass in a stream containing the Google auth settings.');\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('error', reject)\n                .on('data', chunk => (s += chunk))\n                .on('end', () => {\n                try {\n                    try {\n                        const data = JSON.parse(s);\n                        const r = this._cacheClientFromJSON(data, options);\n                        return resolve(r);\n                    }\n                    catch (err) {\n                        // If we failed parsing this.keyFileName, assume that it\n                        // is a PEM or p12 certificate:\n                        if (!this.keyFilename)\n                            throw err;\n                        const client = new jwtclient_1.JWT({\n                            ...this.clientOptions,\n                            keyFile: this.keyFilename,\n                        });\n                        this.cachedCredential = client;\n                        this.setGapicJWTValues(client);\n                        return resolve(client);\n                    }\n                }\n                catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Create a credentials instance using the given API key string.\n     * @param apiKey The API key string\n     * @param options An optional options object.\n     * @returns A JWT loaded from the key\n     */\n    fromAPIKey(apiKey, options) {\n        options = options || {};\n        const client = new jwtclient_1.JWT(options);\n        client.fromAPIKey(apiKey);\n        return client;\n    }\n    /**\n     * Determines whether the current operating system is Windows.\n     * @api private\n     */\n    _isWindows() {\n        const sys = os.platform();\n        if (sys && sys.length >= 3) {\n            if (sys.substring(0, 3).toLowerCase() === 'win') {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Run the Google Cloud SDK command that prints the default project ID\n     */\n    async getDefaultServiceProjectId() {\n        return new Promise(resolve => {\n            (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) => {\n                if (!err && stdout) {\n                    try {\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\n                        resolve(projectId);\n                        return;\n                    }\n                    catch (e) {\n                        // ignore errors\n                    }\n                }\n                resolve(null);\n            });\n        });\n    }\n    /**\n     * Loads the project id from environment variables.\n     * @api private\n     */\n    getProductionProjectId() {\n        return (process.env['GCLOUD_PROJECT'] ||\n            process.env['GOOGLE_CLOUD_PROJECT'] ||\n            process.env['gcloud_project'] ||\n            process.env['google_cloud_project']);\n    }\n    /**\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n     * @api private\n     */\n    async getFileProjectId() {\n        if (this.cachedCredential) {\n            // Try to read the project ID from the cached credentials file\n            return this.cachedCredential.projectId;\n        }\n        // Ensure the projectId is loaded from the keyFile if available.\n        if (this.keyFilename) {\n            const creds = await this.getClient();\n            if (creds && creds.projectId) {\n                return creds.projectId;\n            }\n        }\n        // Try to load a credentials file and read its project ID\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n        if (r) {\n            return r.projectId;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Gets the project ID from external account client if available.\n     */\n    async getExternalAccountClientProjectId() {\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            return null;\n        }\n        const creds = await this.getClient();\n        // Do not suppress the underlying error, as the error could contain helpful\n        // information for debugging and fixing. This is especially true for\n        // external account creds as in order to get the project ID, the following\n        // operations have to succeed:\n        // 1. Valid credentials file should be supplied.\n        // 2. Ability to retrieve access tokens from STS token exchange API.\n        // 3. Ability to exchange for service account impersonated credentials (if\n        //    enabled).\n        // 4. Ability to get project info using the access token from step 2 or 3.\n        // Without surfacing the error, it is harder for developers to determine\n        // which step went wrong.\n        return await creds.getProjectId();\n    }\n    /**\n     * Gets the Compute Engine project ID if it can be inferred.\n     */\n    async getGCEProjectId() {\n        try {\n            const r = await gcpMetadata.project('project-id');\n            return r;\n        }\n        catch (e) {\n            // Ignore any errors\n            return null;\n        }\n    }\n    getCredentials(callback) {\n        if (callback) {\n            this.getCredentialsAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getCredentialsAsync();\n        }\n    }\n    async getCredentialsAsync() {\n        const client = await this.getClient();\n        if (client instanceof impersonated_1.Impersonated) {\n            return { client_email: client.getTargetPrincipal() };\n        }\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n            const serviceAccountEmail = client.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                return {\n                    client_email: serviceAccountEmail,\n                    universe_domain: client.universeDomain,\n                };\n            }\n        }\n        if (this.jsonContent) {\n            return {\n                client_email: this.jsonContent.client_email,\n                private_key: this.jsonContent.private_key,\n                universe_domain: this.jsonContent.universe_domain,\n            };\n        }\n        if (await this._checkIsGCE()) {\n            const [client_email, universe_domain] = await Promise.all([\n                gcpMetadata.instance('service-accounts/default/email'),\n                this.getUniverseDomain(),\n            ]);\n            return { client_email, universe_domain };\n        }\n        throw new Error(GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);\n    }\n    /**\n     * Automatically obtain an {@link AuthClient `AuthClient`} based on the\n     * provided configuration. If no options were passed, use Application\n     * Default Credentials.\n     */\n    async getClient() {\n        if (!this.cachedCredential) {\n            if (this.jsonContent) {\n                this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n            }\n            else if (this.keyFilename) {\n                const filePath = path.resolve(this.keyFilename);\n                const stream = fs.createReadStream(filePath);\n                await this.fromStreamAsync(stream, this.clientOptions);\n            }\n            else {\n                await this.getApplicationDefaultAsync(this.clientOptions);\n            }\n        }\n        return this.cachedCredential;\n    }\n    /**\n     * Creates a client which will fetch an ID token for authorization.\n     * @param targetAudience the audience for the fetched ID token.\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n     */\n    async getIdTokenClient(targetAudience) {\n        const client = await this.getClient();\n        if (!('fetchIdToken' in client)) {\n            throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n        }\n        return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });\n    }\n    /**\n     * Automatically obtain application default credentials, and return\n     * an access token for making requests.\n     */\n    async getAccessToken() {\n        const client = await this.getClient();\n        return (await client.getAccessToken()).token;\n    }\n    /**\n     * Obtain the HTTP headers that will provide authorization for a given\n     * request.\n     */\n    async getRequestHeaders(url) {\n        const client = await this.getClient();\n        return client.getRequestHeaders(url);\n    }\n    /**\n     * Obtain credentials for a request, then attach the appropriate headers to\n     * the request options.\n     * @param opts Axios or Request options on which to attach the headers\n     */\n    async authorizeRequest(opts) {\n        opts = opts || {};\n        const url = opts.url || opts.uri;\n        const client = await this.getClient();\n        const headers = await client.getRequestHeaders(url);\n        opts.headers = Object.assign(opts.headers || {}, headers);\n        return opts;\n    }\n    /**\n     * Automatically obtain application default credentials, and make an\n     * HTTP request using the given options.\n     * @param opts Axios request options for the HTTP request.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request(opts) {\n        const client = await this.getClient();\n        return client.request(opts);\n    }\n    /**\n     * Determine the compute environment in which the code is running.\n     */\n    getEnv() {\n        return (0, envDetect_1.getEnv)();\n    }\n    /**\n     * Sign the given data with the current private key, or go out\n     * to the IAM API to sign it.\n     * @param data The data to be signed.\n     * @param endpoint A custom endpoint to use.\n     *\n     * @example\n     * ```\n     * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');\n     * ```\n     */\n    async sign(data, endpoint) {\n        const client = await this.getClient();\n        const universe = await this.getUniverseDomain();\n        endpoint =\n            endpoint ||\n                `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;\n        if (client instanceof impersonated_1.Impersonated) {\n            const signed = await client.sign(data);\n            return signed.signedBlob;\n        }\n        const crypto = (0, crypto_1.createCrypto)();\n        if (client instanceof jwtclient_1.JWT && client.key) {\n            const sign = await crypto.sign(client.key, data);\n            return sign;\n        }\n        const creds = await this.getCredentials();\n        if (!creds.client_email) {\n            throw new Error('Cannot sign data without `client_email`.');\n        }\n        return this.signBlob(crypto, creds.client_email, data, endpoint);\n    }\n    async signBlob(crypto, emailOrUniqueId, data, endpoint) {\n        const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);\n        const res = await this.request({\n            method: 'POST',\n            url: url.href,\n            data: {\n                payload: crypto.encodeBase64StringUtf8(data),\n            },\n            retry: true,\n            retryConfig: {\n                httpMethodsToRetry: ['POST'],\n            },\n        });\n        return res.data.signedBlob;\n    }\n}\nexports.GoogleAuth = GoogleAuth;\n/**\n * Export DefaultTransporter as a static property of the class.\n */\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\n"]},"metadata":{},"sourceType":"script"}